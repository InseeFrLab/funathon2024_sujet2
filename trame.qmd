---
title: "Un tableau de bord du trafic a√©rien avec {{< fa brands r-project >}} ou {{< fa brands python >}}"
number-sections: true
filters:
   - include-code-files
---

```{=html}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.25&autoLaunch=true&networking.user.enabled=true&git.repository=¬´https%3A%2F%2Fgithub.com%2FInseeFrLab%2Ffunathon2024_sujet2.git¬ª&onyxia.friendlyName=¬´config-funathon2024¬ª&kubernetes.role=¬´admin¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SSP%20Cloud-Ouvrir_dans_RStudio-blue?logo=rstudio&amp;logoColor=blue" alt="Onyxia"></a>
```


![](img/cockpit.png){width="25%" fig-align="center"}

# Introduction {.unnumbered}

L'objectif de ce tutoriel est d'amener, pas √† pas, √† la conception
voire √† la mise √† disposition d'un tableau de bord
du trafic a√©rien avec {{< fa brands r-project >}}.
Une d√©monstration de cette application est disponible √† l'adresse <>.


L'application interactive propos√©e pr√©sentera un nombre de fonctionnalit√©s
limit√©es afin de se concentrer sur la d√©marche. L'objectif est de construire
progressivement celle-ci en suivant les √©tapes logiques du d√©roulement d'un
projet de d√©veloppement d'application interactive: d√©couverte et exploration des donn√©es, cr√©ation de statistiques
descriptives et de visualisations simples sur un jeu de donn√©es, 
extension du nombre de visualisations accessibles par la cr√©ation d'une application. Ce tutoriel est √©galement l'occasion de d√©couvrir quelques
bonnes pratiques de programmation avec `R` afin de rendre les projets plus
fiables, √©volutifs et lisibles. 

Les exercices de conception pas √† pas de l'application s'adressent aussi bien √† des
d√©butants qu'√† des utilisateurs plus experts. La mise √† disposition, c'est-√†-dire
la mise en production de cette application, fait appel √† des concepts
et outils plus
avanc√©s et est donc moins accessible √† des d√©butants.

::: callout-tip
Si vous d√©sirez aller plus loin sur certaines dimensions de ce projet,
vous pouvez tout √† fait essayer de vous-m√™mes d'introduire de nouveaux
ingr√©dients dans l'application que vous d√©veloppez.
:::




# Exploration des donn√©es de trafic a√©rien


## Pr√©liminaire: r√©cup√©rer le projet squelette avec `Git` {{< fa brands git-alt >}}

Si vous disposez d'un compte sur le [sspcloud](https://www.sspcloud.fr/),
la m√©thode recommand√©e pour se lancer dans ce tutoriel est de cliquer
sur le bouton suivant

```{=html}
<center>
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.25&autoLaunch=true&networking.user.enabled=true&git.repository=¬´https%3A%2F%2Fgithub.com%2FInseeFrLab%2Ffunathon2024_sujet2.git¬ª&onyxia.friendlyName=¬´config-funathon2024¬ª&kubernetes.role=¬´admin¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SSP%20Cloud-Ouvrir_dans_RStudio-blue?logo=rstudio&amp;logoColor=blue" alt="Onyxia"></a>
</center>
<br>
```



Si vous avez utilis√© le lien de lancement rapide mis √† disposition
sur la page [inseefrlab.github.io/funathon2024/](https://inseefrlab.github.io/funathon2024/)
ou ci-dessus, 
vous pouvez sauter l'√©tape de r√©cup√©ration du mod√®le de projet avec `Git`, cela
a √©t√© fait automatiquement lors de la cr√©ation de votre environnement `RStudio`. 

::: {.callout-note collapse="true"}
## R√©cup√©rer le projet si vous n'avez pas utilis√© le bouton propos√©

:::: {.panel-tabset}
## Interface graphique

La fiche `utilitR` sur l'[utilisation de `Git`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_git_utilisation.html#recuperer-url
) explicite la d√©marche g√©n√©rale pour
r√©cup√©rer du code gr√¢ce √† `Git`. Il est recommand√© de lire celle-ci si vous
n'√™tes pas familier de `Git`. 

Les √©tapes suivantes permettront de r√©cup√©rer le projet:

1Ô∏è‚É£ En premier lieu, dans `RStudio`, cr√©er un nouveau projet et s√©lectionner `Version Control`. 

![](https://book.utilitr.org/pics_resized/git/create_project_1.png)

2Ô∏è‚É£ Choisir `Git`, ce qui devrait ouvrir une fen√™tre similaire √† celle ci-dessous:

![](https://book.utilitr.org/pics_resized/git/create_project_2.png)

3Ô∏è‚É£ Dans la fen√™tre `Repository URL`, passer la valeur

```r
https://github.com/inseefrlab/funathon2024_sujet2.git
```

laisser les valeurs par d√©faut qui viennent ensuite et cr√©er le projet. 


## Depuis le terminal

Apr√®s avoir ouvert un terminal dans `RStudio`, faire 

```bash
git clone https://github.com/inseefrlab/funathon2024_sujet2.git
```

puis, dans l'explorateur de fichiers (fen√™tre en bas √† droite), cliquer
sur le fichier `RTraffic.Rproj` pour ouvrir le projet. 
::::

:::

Le projet r√©cup√©r√© comporte de nombreux fichiers. Nous allons 
progressivement les d√©couvrir dans ce tutoriel. A l'heure actuelle,
on peut se concentrer sur les fichiers suivants:

```
|- renv.lock
|- global.R
|- server.R
|- ui.R
```

Le premier fichier correspond √† la liste des _packages_ n√©cessaires
pour reproduire l'environnement. Il a √©t√© g√©n√©r√© automatiquement gr√¢ce √† 
un √©cosyst√®me `renv` particuli√®rement adapt√© pour assurer la reproductibilit√©
de projets `R` (voir la suite). 

Les fichiers `server.R` et `ui.R` constituent le coeur de notre application 
`Shiny`. Ils repr√©sentent, respectivement, le moteur de calcul (le serveur)
et l'interface utilisateur de notre application. Le fichier `global.R` stocke
un certain nombre d'objets utiles √† l'application mais qui n'ont pas besoin
d'√™tre recalcul√© √† chaque action sur l'interface graphique. 


## Installer les _packages_ n√©cessaires pour ce tutoriel

### Principe

Pour progresser dans ce tutoriel, un certain nombre de _packages_
doivent √™tre install√©s. Sans eux, m√™me avec le code de l'application, vous
ne serez pas en mesure de reproduire celle-ci. 

Les bonnes pratiques pour la gestion de 
l'environnement sont assez proches en {{< fa brands r-project >}} et {{< fa brands python >}}.
Le principal g√©n√©ral est qu'il existe des outils qui permettent √† un utilisateur de lister l'ensemble des packages dans son environnement avec leur version. Gr√¢ce √† cette liste, d'autres personnes pourront reproduire l'application si elles disposent des m√™mes _inputs_ (le code, les donn√©es...). 

En effet, il est important de voir l'application comme le r√©sultat de la combinaison de plusieurs ingr√©dients. Dans notre cas, nous en avons trois:

* Du code `R` ou `Python` : celui-ci a √©t√© r√©cup√©r√© par le biais de `Git`
* Des √©l√©ments de configuration:
    + le fichier `renv.lock` (`R`) ou `requirements.txt` (`Python`) qui permettra de reconstruire notre environnement √† l'identique gr√¢ce √† des outils adapt√©s[^generation]
    + le fichier `sources.yaml` qui liste l'emplacement des sources sur le site [data.gouv](https://www.data.gouv.fr/fr/)
* Des donn√©es: nous √©voquerons celles-ci lors de la prochaine partie.


![Illustration du principe de s√©paration du code, des donn√©es et de la configuration](./img/environment.png)

De mani√®re g√©n√©rale, c'est une bonne pratique de structurer son projet comme une
combinaison de ces facteurs. Cela vous am√®nera √† faire des projets plus reproductible
mais aussi √† la structure plus lisible. 

Pour les utilisateurs de `R`, la [formation de l'Insee aux bonnes pratiques](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/)
consacre une partie aux environnements reproductibles avec `renv`. Pour les utilisateurs
de `Python`, le [cours de mise en production de projets _data science_](https://ensae-reproductibilite.github.io/website/chapters/portability.html)
consacre un chapitre au sujet. 

[^generation]: Ces fichiers ne sont pas g√©n√©r√©s manuellement. Ce sont des outils adapt√©s (`renv` pour `R`, `pip` pour `Python`) qui font ce travail de versionnage de l'environnement. 

### Cr√©er l'environnement

L'int√©r√™t d'utiliser `renv` est que recr√©er l'environnement n√©cessaire
au bon fonctionnement de l'application est tr√®s simple avec la commande:

```r
renv::restore()
```

Il est tout √† fait possible, ensuite, d'installer des _packages_ suppl√©mentaires
par le biais de `install.packages`. L'environnement propos√© par notre fichier
`renv.lock` est le minimum
requis pour reproduire l'application mais ce n'est pas un environnement fig√©.
Si vous ajoutez des _packages_ utiles pour votre application, avant la phase de mise en production, n'oubliez pas
de faire `renv::snapshot()` pour mettre √† jour le fichier `renv.lock`. 

Maintenant que nous disposons d'un environnement fonctionnel, 
nous pouvons avancer sur la conception du projet. La premi√®re √©tape est d'explorer
les jeux de donn√©es que nous utiliserons dans l'application

# R√©cup√©rer les donn√©es

Les sources sont list√©es dans le fichier `sources.yaml`. 
Notre application utilisera quatres sources diff√©rentes:

- Le trafic au niveau de chaque a√©roport (format CSV)
- Le nombre de passagers pour diff√©rentes liaisons (format CSV)
- Le trafic pour diff√©rentes compagnies (format CSV)
- Les localisations des a√©roports (format geojson)

## Importer la liste des sources disponibles

::: {.callout-note}
## Exercice 1: lire les sources dans {{< fa brands r-project >}}

1. Le package `yaml` comporte une fonction `read_yaml` pour transformer
un fichier `YAML` en liste imbriqu√©e. Tester cette fonction sur le fichier `sources.yml`. 

2. Transformer ce bout de code en une fonction `create_data_list`
prenant un argument `source_file` et renvoyant cette liste.

:::

<details>
<summary>
Voir la solution
</summary>
```{.r include="R/create_data_list.R"}
```


</details>

La solution est dans le fichier `R/create_data_list.R`. Elle peut √™tre import√©e
dans l'environnement global gr√¢ce √† la commande:

```{r}
source("R/create_data_list.R")
```

## Importer les premi√®res bases 

```{r}
urls <- create_data_list("sources.yml")
```


::: {.callout-note}
## Exercice 2: d√©couvrir les diff√©rentes sources

Cet exercice est, en apparence, un peu long. N√©anmoins la premi√®re partie
de celui-ci permet la construction d'une fonction g√©n√©rique d'import
des donn√©es qui permet ensuite de gagner
du temps et d'√©viter la redondance de code. 

#### Donn√©es a√©roports {.unnumbered}

* Comme les donn√©es sont des CSV europ√©ens (s√©parateur `;`),
utiliser `read_csv2` du package `readr` pour lire les donn√©es √† partir 
de la liste de fichiers `unlist(urls$airports)`[^utilitr-csv].
* Il est recommand√© de ne pas laisser les types par d√©faut des colonnes mais de figer ceux-ci avec l'argument suivant:

```{.r}
col_types = cols(
  ANMOIS = col_character(),
  APT = col_character(),
  APT_NOM = col_character(),
  APT_ZON = col_character(),
  .default = col_double()
)
```

* A partir de la variable `ANMOIS`, cr√©er les variables `an` et `mois`.

<details>
<summary>
Aide si vous √™tes bloqu√© sur cette question
</summary>

Pour extraire des √©l√©ments d'une chaine de caract√®re √† partir de la position, il est recommand√© d'utiliser la fonction `str_sub` du package `stringr`. Pour cr√©er de nouvelles colonnes, il est recommand√© d'utiliser la fonction `mutate` du package dplyr. 

Si vous √™tes toujours bloqu√©, la solution est donn√©e plus bas üëá

</details>

* Cr√©er une fonction `clean_dataframe` qui reprend le code de cr√©ation des variables `an` et `mois`, ajoute une √©tape de passage des noms de colonne en minuscule et renvoie le dataframe en sortie

<details>
<summary>
Solution
</summary>

```{.r include="R/clean_dataframe.R"}
```
</details>

* Cr√©er une fonction `import_airport_data` qui prend en _input_ `list_files`
et int√®gre les deux √©tapes pr√©c√©dentes: la lecture des donn√©es, le nettoyage
avec `clean_dataframe`.

<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=1 end-line=17}
```

* Reporter cette fonction dans un fichier `R/clean_dataframe.R` et faire

```{.r}
source("R/clean_dataframe.R")
```

</details>

#### Donn√©es compagnies {.unnumbered}

Sur le m√™me principe, cr√©er une fonction `import_compagnies_data` qui effectue
la m√™me suite d'op√©rations. Faire n√©anmoins attention aux types des colonnes. 

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Recommandation de param√®tre pour read_csv pour l'import de ces fichiers"
col_types = cols(
  ANMOIS = col_character(),
  CIE = col_character(),
  CIE_NOM = col_character(),
  CIE_NAT = col_character(),
  CIE_PAYS = col_character(),
  .default = col_double()
)
```


<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=20 end-line=38}
```

</details>

#### Donn√©es liaisons  {.unnumbered}

Sur le m√™me principe, cr√©er une fonction `import_liaisons_data` qui effectue
la m√™me suite d'op√©rations. Faire n√©anmoins attention aux types des colonnes. 

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Recommandation de param√®tre pour read_csv pour l'import de ces fichiers"
col_types = cols(
  ANMOIS = col_character(),
  LSN = col_character(),
  LSN_DEP_NOM = col_character(),
  LSN_ARR_NOM = col_character(),
  LSN_SCT = col_character(),
  LSN_FSC = col_character(),
  .default = col_double()
)
```

<details>
<summary>
Solution
</summary>

```{.r include="R/import_data.R" start-line=41 end-line=60}
```

</details>

#### Localisations des a√©roports {.unnumbered}

Il s'agit d'un jeu de donn√©es spatial. Pour en savoir plus sur ce type de donn√©es,
il est recommand√© de consulter la [fiche  `utilitR`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_donnees_spatiales.html) sur
le sujet ou [ce cours introductif](https://rgeo.linogaliana.fr/exercises/geospatial-wrangling.html) 

1. Utiliser la fonction `st_read` du package `sf` pour lire ces donn√©es (dont la localisation est stock√©e dans la variable `urls$geojson$aiport`). Stocker l'objet obtenu sous le nom `airports_location`
2. V√©rifier que les donn√©es sont bien dans le syst√®me de repr√©sentation `WGS 84`[^crs]

<details>
<summary>
Aide
</summary>
La fonction √† utiliser est `sf_crs`
</details>

3. Il est toujours utile de v√©rifier que nos donn√©es sont bien localis√©es o√π on les attend. Pour cela, il est pertinent de faire une carte avec un fond de carte contextuel, m√™me si celle-ci n'est pas tr√®s soign√©e. Pour faire ceci, le plus simple est d'utiliser la [fonction `addMarkers`](https://rstudio.github.io/leaflet/articles/markers.html) du package `leaflet`.
Essayez de faire cette carte vous-m√™mes ou consultez l'aide ci-dessous

<details>
<summary>
Code pour faire une carte `leaflet` minimale
</summary>
```{.r}
leaflet(airports_location) %>%
  addTiles() %>%
  addMarkers(popup = ~Nom)
```
</details>

Reporter toutes ces fonctions dans un fichier `R/import_data.R`. 
:::

[^utilitr-csv]: Si vous √™tes peu familier avec ce type de fichiers, vous pouvez consulter la [fiche `utilitR`](https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_plats.html) sur le sujet
[^crs]: Si vous √™tes peu familier avec les donn√©es g√©ographiques, vous pouvez retenir l'id√©e qu'il s'agit de donn√©es traditionnelles auxquelles s'ajoute une dimension spatiale. Cette derni√®re vise √† localiser les donn√©es sur la terre. La localisation se fait dans un espace √† deux dimensions (espace cart√©sien) alors que notre plan√®te est une sph√®re en trois dimensions. Le principe d'un syst√®me de projection est de faire ce passage en deux dimensions des positions. Le plus connu est le syst√®me GPS, qui est un h√©ritier lointain de la repr√©sentation du monde par [Mercator](https://fr.wikipedia.org/wiki/G%C3%A9rard_Mercator). Ce syst√®me est connu sous le nom de WGS 84 et porte le code EPSG 4326. L'autre syst√®me √† retenir est le Lambert 93 (code EPSG 2154) qui est la projection l√©gale en France (celle-ci, _a contrario_ du Mercator, ne d√©forme pas la France sur une carte). Pour en savoir plus sur les syst√®mes de repr√©sentation, les avantages et inconv√©nients de chacun, il existe de nombreuses ressources en ligne. Des √©l√©ments introductifs, et des d√©monstrations interactives, en lien avec la librairie `Geopandas` de `Python` sont disponibles [ici](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_intro.html#principe). 


A l'issue de cet exercice, vous devriez avoir le fichier `R/import_data.R` suivant

<details>
<summary>
Le fichier `R/import_data.R` attendu
</summary>

```{.r include="R/import_data.R"}
```

</details>

La carte `leaflet` que vous devriez avoir obtenue √† la fin de l'exercice
est la suivante:

```{r}
#| echo: false
#| output: false
library(sf)
library(leaflet)
airports_location <- st_read(urls$geojson$airport)
```

```{r}
leaflet(airports_location) %>%
  addTiles() %>%
  addMarkers(popup = ~Nom)
```

A l'issue de l'exercice, 
le code centralis√© dans le script `R/import_data.R`
peut √™tre import√© via le code suivant

```{r}
source("R/import_data.R")  
```

Vous pouvez initier un script nomm√© `main.R` avec les lignes suivante:

```{.r include="global.R" start-line=23 end-line=33}
```

en les faisant pr√©c√©der de l'import des
scripts que nous avons d√©j√† cr√©√© dans le dossier `R`:

```r
source("R/create_data_list.R")
source("R/import_data.R")  
source("R/clean_dataframe.R")
```

Une bonne pratique est de tester son script dans une session vierge. Cela am√®ne
√† construire pas √† pas une chaine plus reproductible. Pour cela, 

- Aller dans les options de `R` via `Tools > Global Options` et d√©cocher la case `Restore .RData into workspace at setup`
- Red√©marrer votre
session `R` via le menu `Session > Restart R` ou le
raccourci <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>F10</kbd>

Et ex√©cuter votre fichier `main.R`. Vous devriez rencontrer des erreurs car nous n'avons pas g√©r√© les import de librairies dans ce script puisque notre session actuelle ne b√©n√©ficie plus des import ant√©rieurs.

Une bonne pratique pour comprendre cette exigence de reproductibilit√©
est d'it√©rativement ajouter les librairies utiles √† mesure qu'on rencontre des erreurs (notre code √©tant tr√®s rapide √† tourner, cette logique d'essai-erreur n'est pas tr√®s co√ªteuse). 
Si vous ne d√©sirez pas faire ceci (dommage, c'est un bon exercice), vous
pouvez trouver les imports de packages √† faire pour que notre script soit
reproductible. 

<details>
<summary>
L'environnement minimal de reproductibilit√© pour que le script `main.R` fonctionne
</summary>

```{.r}
library(readr)
library(dplyr)
library(stringr)
library(sf)
``` 

</details>

Ces librairies sont √† √©crire au d√©but de `main.R`. 


# Exploration des donn√©es

```{r}
#| label: intermediates-exo2
#| echo: false
#| output: false
source("intermediates/exo2.R")
```


## Le trafic par a√©roport

Pour commencer, nous allons prototyper la production d'une figure
sur le trafic a√©rien au niveau d'un a√©roport. Cela nous facilitera ensuite
l'int√©gration dans une application interactive. 

Pour cela, nous allons cr√©er les deux objets temporaires suivants

```{r}
liste_aeroports <- unique(pax_apt_all$apt)
default_airport <- liste_aeroports[1]
default_airport
```

```{r}
#| output: false
source("intermediates/exo3.R")
```

::: {.callout-note}
## Exercice 3: graphiques de fr√©quentation des a√©roports

1. Cr√©er une variable `trafic` √©gale `apt_pax_dep + apt_pax_tr + apt_pax_arr`
2. Ne conserver que les donn√©es relatives √† l'a√©roport `default_airport`
3. Cr√©er une variable `date` qui utilise les colonnes `an` et `mois`. Cette variable de date doit √™tre au format `date`, pas au format `chr`
<details>
<summary>
Encha√Ænement des op√©rations attendues √† cette √©tape
</summary>

```{.r include="intermediates/exo3.R" end-line=10}
```
</details>

4. Faire une figure `ggplot` toute simple pour voir la dynamique des donn√©es
afin d'obtenir une figure similaire √† celle-ci

```{r}
figure_ggplot
```

Nous allons faire une application interactive par la suite. Il est donc
plus int√©ressant d'avoir une figure un minimum r√©active pour impliquer
l'utilisateur de l'application.

5. Il est donc plus pertinent de faire une figure avec la librairie
`plotly`. Pour cela, vous pouvez vous inspirer de [cette page](https://plotly.com/r/line-charts/)

```{r}
#| echo: false
figure_plotly
```

<details>

<summary>
Le code pour g√©n√©rer la figure
</summary>

```{.r include="intermediates/exo3.R" start-line=15}
```

</details>

:::

Le code complet pour r√©pliquer cet exercice est donn√© ci-dessous. 

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="intermediates/exo3.R"}
```
</details>

Nous proposons de le transformer en fonction, ce sera plus simple √† int√©grer
ult√©rieurement dans notre application

::: {.callout-note}
## Exercice 3b: une fonction de production graphique

Transformer le code ci-dessus en une fonction afin que

* les _inputs_ soient les suivants: un _dataframe_, un a√©roport √† s√©lectionner
* la sortie soit notre figure `plotly`

Tester sur d'autres a√©roports de la liste
:::

```{r}
source("intermediates/exo3b.R")
```

<details>
<summary>
Code de l'exercice
</summary>
```{.r include="intermediates/exo3b.R"}
```
</details>

4. Faire une fonction

Faire un tableauDT

Pr√©parer le code pour DT

Appli4

Faire un leaflet

```r
aeroports <- readr::read_csv2("apt_localisation.csv")

library(sf)
aeroports <- st_as_sf(aeroports, coords = c("Longitude", "Latitude"), crs = 4326)

trafic_aeroports <- aeroports %>%
  inner_join(pax_apt, by = c("Code OACI" = "apt")) %>%
  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr)
```

```r
palette <- c("darkred", "forestgreen", "dodgerblue", "gold")
```

```r
trafic_aeroports <- trafic_aeroports %>%
  mutate(
    volume = ntile(trafic, 4)
) %>%
  mutate(
    color = palette[volume]
  )
  
icons <- awesomeIcons(
  icon = 'ios-close',
  iconColor = 'black',
  library = 'ion',
  markerColor = trafic_aeroports$color
)

leaflet(trafic_aeroports) %>% addTiles() %>%
  addMarkers(popup = ~paste0(Nom, ": ", trafic))
  #addAwesomeMarkers(icon=icons, label=~as.character(trafic))
```


Appli5
Pr√©parer un premier shiny sans plotly & leaflet

Appli6
Ajouter √† l'UI le plotly & leaflet

Appli7
Contr√¥le de l'environnement avec renv