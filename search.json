[
  {
    "objectID": "index.html#objectif",
    "href": "index.html#objectif",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "1.1 Objectif",
    "text": "1.1 Objectif\nL‚Äôobjectif de ce tutoriel est d‚Äôamener, pas √† pas, √† la conception voire √† la mise √† disposition d‚Äôun tableau de bord (dashboard) du trafic a√©rien avec  ou . Ce tutoriel est √©galement l‚Äôoccasion d‚Äôapprendre quelques bonnes pratiques pour les projets  et . Une d√©monstration de cette application est disponible sur\n\nhttps://rplane-dashboard.kub.sspcloud.fr/ () ;\nhttps://pylot-dashboard.kub.sspcloud.fr/ ().\n\nL‚Äôobjectif est de construire progressivement cette application en suivant les √©tapes logiques du d√©roulement d‚Äôun projet de d√©veloppement d‚Äôapplication interactive : d√©couverte et exploration des donn√©es, cr√©ation de statistiques descriptives et de visualisations simples sur un jeu de donn√©es, extension du nombre de visualisations accessibles par la cr√©ation d‚Äôune application.\nL‚Äôobjectif secondaire de ce tutoriel est de faire d√©couvrir quelques bonnes pratiques de programmation avec  ou  afin de rendre les projets plus fiables, √©volutifs et lisibles. Comme vous pourrez le faire au cours de celui-ci, la diff√©rence entre ces deux langages est assez minime. L‚Äôun des objectifs de ce tutoriel est de vous amener √† structurer votre projet selon la norme suivante:\n\n\n\n\n\n\n\n(a) Environnement mal structur√©\n\n\n\n\n\n\n\n(b) Environnement bien structur√©\n\n\n\n\nFigure¬†1: L‚Äôenvironnement vers lequel on d√©sire converger\n\n\nLes exercices de conception pas √† pas de l‚Äôapplication s‚Äôadressent aussi bien √† des d√©butants qu‚Äô√† des utilisateurs plus avanc√©s. La mise √† disposition, c‚Äôest-√†-dire la mise en production de cette application, fait toutefois appel √† des concepts et outils plus avanc√©s et est donc moins accessible √† des d√©butants.\n\n\n\n\n\n\nNote\n\n\n\nAfin de se concentrer sur la d√©marche, cette application interactive pr√©sentera un nombre limit√© de fonctionnalit√©s.\nSi vous disposez de temps suppl√©mentaire, n‚Äôh√©sitez pas √† ajouter des fonctionnalit√©s √† celle-ci et √† les proposer pour un ajout dans la galerie du site web du funathon (inseefrlab.github.io/funathon2024/)."
  },
  {
    "objectID": "index.html#pourquoi-d√©velopper-une-application-interactive",
    "href": "index.html#pourquoi-d√©velopper-une-application-interactive",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "1.2 Pourquoi d√©velopper une application interactive ?",
    "text": "1.2 Pourquoi d√©velopper une application interactive ?\nCette question peut appara√Ætre na√Øve. Pourtant, elle m√©rite d‚Äô√™tre pos√©e car elle permet de r√©fl√©chir:\n\n√† l‚Äôobjectif de l‚Äôapplication ;\n√† son public cible.\n\nCette r√©flexion devrait √™tre men√©e syst√©matiquement car elle guide les choix techniques ult√©rieurs et la r√©partition des t√¢ches entre les diff√©rents profils pouvant intervenir dans la vie du projet s‚Äôil est mis en production (statisticien ou data scientist, √©quipes informatiques‚Ä¶).\n\n1.2.1 Une valorisation de donn√©es rapide et attractive\nEn g√©n√©ral, on fait de la visualisation de donn√©es car les sources de donn√©es exploit√©es pr√©sentent tellement de dimensions pouvant int√©resser un utilisateur qu‚Äôil est plus pertinent de le laisser explorer les donn√©es que de d√©finir pour lui les statistiques √† mettre en avant. L‚Äôinteractivit√© permise par les sites web est particuli√®rement adapt√©e pour cela : le fait d‚Äôafficher ou masquer des visualisations en fonction de choix de l‚Äôutilisateur √©vite de noyer l‚Äôinformation par rapport √† des supports fig√©s.\nLes frameworks Shiny (), Streamlit ou Dash () permettent de rapidement mettre en oeuvre ce type de site web. Pour une phase de construction d‚Äôun prototype, c‚Äôest un choix technique int√©ressant qui peut provoquer l‚Äôeffet wahou attendu pour lancer le projet √† plus grande √©chelle. En effet, ces solutions techniques permettent, avec les outils bien connus des praticiens de la donn√©e ( ou ) de cr√©er rapidement un site web fonctionnel, ergonomique et effectuant des op√©rations en fonction d‚Äôactions de l‚Äôutilisateur sur la page web. Tout ceci sans avoir √† ma√Ætriser des notions complexes de d√©veloppement web.\n\n\n1.2.2 Une mise √† disposition parfois complexe\nN√©anmoins, pass√©e cette phase d‚Äôexp√©rimentation, le partage de ces applications, au-del√† d‚Äôun partage d‚Äô√©cran pour des d√©monstrations, n‚Äôest pas toujours √©vident (d‚Äôo√π le fait, nous y reviendrons, que la derni√®re partie de ce tutoriel s‚Äôadresse plut√¥t √† un niveau expert). Cette difficult√© est due au fait qu‚Äôassurer le bon fonctionnement d‚Äôun site web p√©renne requiert la ma√Ætrise de notions complexes, qui ne sont pas n√©cessaires au cours de la phase d‚Äôexp√©rimentation. Celles-ci d√©passent n√©anmoins le champ de comp√©tence des statisticiens ou data scientists.\nAutrement dit, si le projet a l‚Äôambition d‚Äô√™tre partag√© √† une audience large qui n‚Äôa pas les comp√©tences techniques pour faire tourner elle-m√™me le code, il convient de prendre en compte le fait qu‚Äôil faudra dans l‚Äô√©quipe projet des comp√©tencess sp√©cifiques de d√©veloppement web. Si le projet est exp√©rimental, c‚Äôest moins un probl√®me : Shiny, Dash ou Streamlit permettront d‚Äôavoir rapidement un prototype viable.\nIl existe heureusement des solutions techniques plus simples √† mettre en oeuvre que Shiny, Streamlit ou Dash. Les sites web statiques font partie de cet √©ventail des possibles et repr√©sentent souvent une alternative pertinente aux applications interactives √† condition qu‚Äôils soient bien pens√©s. Ils sont notamment pertinents pour les applications de visualisation de donn√©es o√π cette derni√®re est d√©j√† pr√©par√©e en amont. Avoir un serveur R ou Python se justifie en effet si des √©tapes complexes de structuration de donn√©es interviennent. Inversement, si aucun traitement de donn√©es complexe n‚Äôest n√©cessaire, un simple enrobage avec un constructeur de site comme Quarto peut suffire, √† condition que les productions graphiques ne soient pas trop complexes √† cr√©er. Pour des sites faisant intervenir des interactions multiples entre actions d‚Äôun utilisateur (bouton, menu d√©roulant, etc. ) et affichage, il faudra recourir √† du Javascript (technologie utilis√©e par les sites sp√©cialis√©s dans la dataviz), ce qui fait, √† nouveau, appel √† des comp√©tences qui d√©passent celles des data scientists ou statisticiens classiques.\nEn r√©sum√©, les √©l√©ments ci-dessus ont vocation √† servir de mise en garde. Shiny, Dash ou Streamlit sont d‚Äôexcellents outils techniques lorsqu‚Äôils sont utilis√©s √† bon escient. Ceci dit, leur simplicit√© d‚Äôusage ne dispense pas de se poser des questions cruciales comme celles du cycle de vie du projet, du public cible ou encore de la comp√©tence des √©quipes amen√©es √† maintenir le projet s‚Äôil perdure au-del√† d‚Äôune phase d‚Äôexp√©rimentation.\n\n\n\n\n\n\nSite statique vs application r√©active\n\n\n\n\n\nLa distinction principale entre ces deux approches est qu‚Äôelles s‚Äôappuient sur des serveurs diff√©rents. Un site statique repose sur un serveur web l√† o√π Shiny/Streamlit s‚Äôappuient sur des serveurs classiques en backend. La diff√©rence principale entre ces deux types de serveurs r√©side principalement dans leur fonction et leur utilisation :\n\nUn serveur web est sp√©cifiquement con√ßu pour stocker, traiter et livrer des pages web aux clients. Cela inclut des fichiers HTML, CSS, JavaScript, images, etc. Les serveurs web √©coutent les requ√™tes HTTP/HTTPS provenant des navigateurs des utilisateurs et y r√©pondent en envoyant les donn√©es demand√©es.\nUn serveur backend classique est con√ßu pour effectuer des op√©rations en r√©ponse √† un front, en l‚Äôoccurrence une page web. Dans le contexte d‚Äôune application Streamlit (resp. Shiny), il s‚Äôagit d‚Äôun serveur avec l‚Äôenvironnement Python (resp. R) ad hoc pour ex√©cuter le code n√©cessaire √† r√©pondre √† toute action d‚Äôun utilisateur de l‚Äôapplication."
  },
  {
    "objectID": "index.html#pr√©liminaire-r√©cup√©rer-le-projet-squelette-avec-git-fa-brands-git-alt",
    "href": "index.html#pr√©liminaire-r√©cup√©rer-le-projet-squelette-avec-git-fa-brands-git-alt",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "2.1 Pr√©liminaire : r√©cup√©rer le projet squelette avec Git ",
    "text": "2.1 Pr√©liminaire : r√©cup√©rer le projet squelette avec Git \nSi vous disposez d‚Äôun compte sur le sspcloud, la m√©thode recommand√©e pour se lancer dans ce tutoriel est de cliquer sur le bouton suivant\n\n\n\n\nLa d√©marche de r√©cup√©ration a √©t√© expliqu√©e au cours de la pr√©sentation de l‚Äôenvironnement technique. Voici, en r√©sum√©, les gestes √† faire:\n\nForker le d√©p√¥t  InseeFrLab/funathon2024_sujet2\nCliquer sur le bouton ci-dessous:\n\n\n\n\n\n\nSur la page SSPCloud qui s‚Äôouvre, changer l‚ÄôURL indiqu√© dans l‚Äôonglet Git pour mettre celui de votre fork\n\nRevoir la vid√©o de pr√©sentation sur https://inseefrlab.github.io/funathon2024 (√† d√©marrer √† partir de 1h29mn)\n\n\nLa d√©marche de r√©cup√©ration est assez similaire √† celle expliqu√©e pour . Voici, en r√©sum√©, les gestes √† faire:\n\nForker le d√©p√¥t  InseeFrLab/funathon2024_sujet2\nCliquer sur le bouton ci-dessous:\n\n\n\n\n\n\nSur la page SSPCloud qui s‚Äôouvre, changer l‚ÄôURL indiqu√© dans l‚Äôonglet Git pour mettre celui de votre fork\n\nRevoir la vid√©o de pr√©sentation sur https://inseefrlab.github.io/funathon2024 (√† d√©marrer √† partir de 1h29mn)\n\n\n\nSi vous avez utilis√© le lien de lancement rapide mis √† disposition sur la page inseefrlab.github.io/funathon2024/ ou ci-dessus ‚òùÔ∏è, vous pouvez sauter l‚Äô√©tape de r√©cup√©ration du mod√®le de projet avec Git , cela a √©t√© fait automatiquement lors de la cr√©ation de votre environnement RStudio ou VSCode. Cela ne vous dispense pas de faire du Git tout au long du tutoriel üò∫, c‚Äôest une bonne pratique, m√™me sur des projets ponctuels ou vous √™tes seuls √† travailler.\n\n\n\n\n\n\nR√©cup√©rer le projet si vous n‚Äôavez pas utilis√© le bouton propos√©\n\n\n\n\n\n\n\n\n\n\nInterface graphiqueDepuis le terminal\n\n\nLa fiche utilitR sur l‚Äôutilisation de Git explicite la d√©marche g√©n√©rale pour r√©cup√©rer du code gr√¢ce √† Git. Il est recommand√© de lire celle-ci si vous n‚Äô√™tes pas familier de Git.\nLes √©tapes suivantes permettront de r√©cup√©rer le projet:\n1Ô∏è‚É£ En premier lieu, dans RStudio, cr√©er un nouveau projet et s√©lectionner Version Control.\n\n2Ô∏è‚É£ Choisir Git, ce qui devrait ouvrir une fen√™tre similaire √† celle ci-dessous:\n\n3Ô∏è‚É£ Dans la fen√™tre Repository URL, passer la valeur\nhttps://github.com/inseefrlab/funathon2024_sujet2.git\nlaisser les valeurs par d√©faut qui viennent ensuite et cr√©er le projet.\n\n\nApr√®s avoir ouvert un terminal dans RStudio, faire\ngit clone https://github.com/inseefrlab/funathon2024_sujet2.git\npuis, dans l‚Äôexplorateur de fichiers (fen√™tre en bas √† droite), cliquer sur le fichier RTraffic.Rproj pour ouvrir le projet.\n\n\n\n\n\n\nOuvrir un terminal depuis VSCode (Terminal &gt; New Terminal).\nR√©cup√©rer, sur la page d‚Äôaccueil de votre d√©p√¥t, l‚Äôurl du d√©p√¥t distant. Il prend la forme suivante\n\nhttps://github.com/&lt;username&gt;/&lt;reponame&gt;.git\n\nDans le terminal, taper\n\ngit clone repo_url\no√π repo_url est l‚ÄôURL de votre fork"
  },
  {
    "objectID": "index.html#se-placer-dans-lenvironnement-du-projet",
    "href": "index.html#se-placer-dans-lenvironnement-du-projet",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "2.2 Se placer dans l‚Äôenvironnement du projet",
    "text": "2.2 Se placer dans l‚Äôenvironnement du projet\n\n\n\n\nA la racine du projet, on trouve notamment le fichier RTraffic.Rproj. Il s‚Äôagit d‚Äôun fichier de projet RStudio. Lorsqu‚Äôon travaille sur du code  avec RStudio, il est g√©n√©ralement pr√©f√©rable de travailler dans le cadre d‚Äôun projet.\nEntre autres raisons, √©voqu√©es dans la documentation utilitR, cela favorise la reproductibilit√©: lorsqu‚Äôon se situe dans un projet RStudio, tous les chemins peuvent √™tre d√©finis de mani√®re relative (√† la racine du projet) plut√¥t que de mani√®re absolue (√† la racine de la machine). Ainsi, le projet s‚Äôex√©cutera de la m√™me mani√®re qu‚Äôil soit ex√©cut√© depuis une machine Windows ou Linux par exemple, avec des noms d‚Äôutilisateurs diff√©rents ou s‚Äôils se situent dans des dossiers diff√©rents au sein de ‚ÄúMes Documents‚Äù.\n\n\n\n\n\n\nPlus de d√©tails dans utilitR\n\n\n\n\n\nPour plus de d√©tails sur les b√©n√©fices d‚Äôutiliser les projets RStudio ou leur utilisation en pratique, n‚Äôh√©sitez pas √† consulter la fiche utilitR d√©di√©e.\n\n\n\n\n\nLes utilisateurs de  connaissent deux environnements de travail tr√®s diff√©rents: la ligne de commande pour ex√©cuter des scripts ou les notebooks Jupyter pour avoir un environnement interactif.\nLes seconds sont pratiques pour prototyper et exp√©rimenter. Mais ils ne sont pas faits pour construire des applications. Nous proposons donc la m√©thode de travail suivante:\n\nCr√©er un Jupyter Notebook √† la racine du projet (au m√™me niveau que le README.md)1. Celui-ci sera votre espace pour √©crire du code exp√©rimental. Lorsqu‚Äôil sera fonctionnel, vous pourrez le reporter dans des scripts comme indiqu√©s dans les consignes.\nDans un terminal, faire cd funathon2024_sujet2 (ou remplacer par le nom de dossier diff√©rent si vous l‚Äôavez chang√©). C‚Äôest dans ce terminal que vous testerez vos scripts. Pour ouvrir un terminal, il suffit de cliquer sur le menu VScode en haut √† gauche (les trois petites barres horizontales), puis Terminal &gt; New Terminal."
  },
  {
    "objectID": "index.html#architecture-du-projet",
    "href": "index.html#architecture-du-projet",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "2.3 Architecture du projet",
    "text": "2.3 Architecture du projet\nLe projet r√©cup√©r√© comporte de nombreux fichiers. Nous allons progressivement les d√©couvrir dans ce tutoriel. A l‚Äôheure actuelle, on peut se concentrer sur les fichiers suivants:\n\n\n\n\nfunathon_sujet2/\n‚îú‚îÄ‚îÄ renv.lock\n‚îú‚îÄ‚îÄ correction/R/\n‚îú‚îÄ‚îÄ correction/global.R\n‚îú‚îÄ‚îÄ correction/server.R\n‚îî‚îÄ‚îÄ correction/ui.R\nLe premier fichier (renv.lock) correspond √† la liste des packages n√©cessaires pour reproduire l‚Äôenvironnement. Il a √©t√© g√©n√©r√© automatiquement gr√¢ce √† un √©cosyst√®me renv particuli√®rement adapt√© pour assurer la reproductibilit√© de projets  (voir la suite).\nLes fichiers server.R et ui.R constituent le coeur de notre application Shiny. Ils repr√©sentent, respectivement, le moteur de calcul (le serveur) et l‚Äôinterface utilisateur de notre application. Nous reviendrons sur ce concept. Le fichier global.R stocke un certain nombre d‚Äôobjets utiles √† l‚Äôapplication mais qui n‚Äôont pas besoin d‚Äô√™tre recalcul√©s √† chaque action sur l‚Äôinterface graphique. Nous allons progressivement construire ces fichiers pendant les diff√©rents exercices. De nombreuses fonctions sont report√©es dans les fichiers au sein du dossier R/.\n\n\nObserver la composition de ce fichier (100 premi√®res lignes)\n\n\n\nrenv.lock\n\n{\n  \"R\": {\n    \"Version\": \"4.3.3\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://packagemanager.posit.co/cran/latest\"\n      }\n    ]\n  },\n  \"Packages\": {\n    \"BH\": {\n      \"Package\": \"BH\",\n      \"Version\": \"1.84.0-0\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Hash\": \"a8235afbcd6316e6e91433ea47661013\"\n    },\n    \"DBI\": {\n      \"Package\": \"DBI\",\n      \"Version\": \"1.2.2\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Requirements\": [\n        \"R\",\n        \"methods\"\n      ],\n      \"Hash\": \"164809cd72e1d5160b4cb3aa57f510fe\"\n    },\n    \"DT\": {\n      \"Package\": \"DT\",\n      \"Version\": \"0.33\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"RSPM\",\n      \"Requirements\": [\n        \"crosstalk\",\n        \"htmltools\",\n        \"htmlwidgets\",\n        \"httpuv\",\n        \"jquerylib\",\n        \"jsonlite\",\n        \"magrittr\",\n        \"promises\"\n      ],\n      \"Hash\": \"64ff3427f559ce3f2597a4fe13255cb6\"\n    },\n    \"KernSmooth\": {\n      \"Package\": \"KernSmooth\",\n      \"Version\": \"2.23-22\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Requirements\": [\n        \"R\",\n        \"stats\"\n      ],\n      \"Hash\": \"2fecebc3047322fa5930f74fae5de70f\"\n    },\n    \"MASS\": {\n      \"Package\": \"MASS\",\n      \"Version\": \"7.3-60.0.1\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Requirements\": [\n        \"R\",\n        \"grDevices\",\n        \"graphics\",\n        \"methods\",\n        \"stats\",\n        \"utils\"\n      ],\n      \"Hash\": \"b765b28387acc8ec9e9c1530713cb19c\"\n    },\n    \"Matrix\": {\n      \"Package\": \"Matrix\",\n      \"Version\": \"1.6-5\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Requirements\": [\n        \"R\",\n        \"grDevices\",\n        \"graphics\",\n        \"grid\",\n        \"lattice\",\n        \"methods\",\n        \"stats\",\n        \"utils\"\n      ],\n      \"Hash\": \"8c7115cd3a0e048bda2a7cd110549f7a\"\n    },\n    \"R6\": {\n      \"Package\": \"R6\",\n      \"Version\": \"2.5.1\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"RSPM\",\n      \"Requirements\": [\n        \"R\"\n      ],\n      \"Hash\": \"470851b6d5d0ac559e9d01bb352b4021\"\n    },\n    \"RColorBrewer\": {\n\n\n\n\nfunathon_sujet2/\n‚îú‚îÄ‚îÄ requirements.txt\n‚îú‚îÄ‚îÄ correction/src/\n‚îî‚îÄ‚îÄ correction/app.py\nLe premier fichier (requirements.txt) correspond √† la liste des packages n√©cessaires pour reproduire l‚Äôenvironnement. Il s‚Äôagit d‚Äôun outil particuli√®rement adapt√© pour assurer la reproductibilit√© de projets  (voir la suite).\nLe fichier app.py constitue le coeur de notre application Streamlit. Ils repr√©sentent, respectivement, le moteur de calcul (le serveur) et l‚Äôinterface utilisateur de notre application. Nous reviendrons sur ce concept. Par ailleurs, de nombreuses fonctions utiles pour l‚Äôapplication sont report√©es dans les fichiers au sein du dossier src/ (abr√©viation de ‚Äúsource‚Äù).\n\n\nObserver la composition de ce fichier\n\n\n\nrequirements.txt\n\npandas\ngeopandas\npyyaml\nplotly\nplotnine\ngreat_tables\nfolium\nstreamlit\nstreamlit-folium"
  },
  {
    "objectID": "index.html#installer-les-packages-n√©cessaires-pour-ce-tutoriel",
    "href": "index.html#installer-les-packages-n√©cessaires-pour-ce-tutoriel",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "2.4 Installer les packages n√©cessaires pour ce tutoriel",
    "text": "2.4 Installer les packages n√©cessaires pour ce tutoriel\n\n2.4.1 Principe\nPour progresser dans ce tutoriel, un certain nombre de packages doivent √™tre install√©s. Sans eux, m√™me avec le code de l‚Äôapplication, vous ne serez pas en mesure de reproduire celle-ci.\nLes bonnes pratiques pour la gestion de l‚Äôenvironnement sont assez proches en  et . Le principal g√©n√©ral est qu‚Äôil existe des outils qui permettent √† un utilisateur de lister l‚Äôensemble des packages dans son environnement avec leur version. Gr√¢ce √† cette liste, d‚Äôautres personnes pourront reproduire l‚Äôapplication si elles disposent des m√™mes inputs (le code, les donn√©es‚Ä¶).\nEn effet, il est important de voir l‚Äôapplication comme le r√©sultat de la combinaison de plusieurs ingr√©dients. Dans notre cas, nous en avons trois:\n\nDu code  ou  : celui-ci a √©t√© r√©cup√©r√© gr√¢ce √† Git lors du lancement du projet;\nDes √©l√©ments de configuration:\n\nle fichier renv.lock () ou requirements.txt () qui permettra de reconstruire notre environnement √† l‚Äôidentique gr√¢ce √† des outils adapt√©s2;\nle fichier sources.yaml qui liste l‚Äôemplacement des sources sur le site data.gouv.\n\nDes donn√©es : nous √©voquerons celles-ci lors de la prochaine partie.\n\n\n\n\nIllustration du principe de s√©paration du code, des donn√©es et de la configuration\n\n\nDe mani√®re g√©n√©rale, c‚Äôest une bonne pratique de structurer son projet comme une combinaison de ces facteurs. Cela vous am√®nera √† faire des projets plus reproductibles mais aussi √† la structure plus lisible.\nPour les utilisateurs de R, la formation de l‚ÄôInsee aux bonnes pratiques consacre une partie aux environnements reproductibles avec renv. Pour les utilisateurs de Python, le cours de mise en production de projets data science consacre un chapitre au sujet.\n\n\n2.4.2 Cr√©er l‚Äôenvironnement\nSi vous avez d√©j√† tent√© de partager un code qui fonctionnait chez vous, il est presque certain que la personne ayant voulu le r√©utiliser a rencontr√© une erreur si elle a tent√© de le faire tourner. C‚Äôest tout √† fait normal car vous avez distribu√© votre code, √©ventuellement vos donn√©es, mais pas le troisi√®me pilier de l‚Äôimage pr√©c√©dente, √† savoir la configuration de l‚Äôenvironnement dans lequel votre code fonctionnait. La solution la plus fiable, mais peu pratique, serait de donner votre ordinateur √† la personne qui tente de r√©utiliser votre code. En livrant votre ordinateur, vous fournissez votre environnement de travail mais √©galement beaucoup d‚Äô√©l√©ments suppl√©mentaires qui ne sont pas indispensables √† l‚Äôapplication.\nUne solution plus simple est de fournir les sp√©cifications qui ont permis √† votre code de fonctionner. Dans un monde id√©al, il s‚Äôagit de fournir la liste des packages et leur version. Si la personne √† qui vous partagez votre code et vos donn√©es a cette m√™me liste de versions de packages, et pas de packages suppl√©mentaires venant polluer l‚Äôenvironnement, les chances d‚Äôavoir la m√™me application que vous sont tr√®s √©lev√©es.\nLes solutions techniques pour restaurer un environnement  et  sont l√©g√®rement diff√©rentes et sont d√©crites ci-dessous.\n\n\n\n\nrenv est un gestionnaire de packages qui permet de faire ces deux op√©rations :\n\nEnregistrer la liste de packages apr√®s avoir fait tourner un code\nRestaurer l‚Äôenvironnement √† partir de cette liste\n\nEn l‚Äôoccurrence, pour vous, l‚Äôimportant est le second point: pouvoir recr√©er l‚Äôenvironnement n√©cessaire au bon fonctionnement de l‚Äôapplication. Ceci est tr√®s simple gr√¢ce √† la commande\n\n\nA lancer dans la console R\n\nrenv::restore()\n\nCette commande doit √™tre lanc√©e depuis la console R ouverte dans le projet qui a √©t√© r√©cup√©r√©3. L‚Äôenvironnement cr√©√© n‚Äôest pas fig√©. Il est tout √† fait possible, ensuite, d‚Äôinstaller des packages suppl√©mentaires par le biais de install.packages. L‚Äôenvironnement propos√© par notre fichier renv.lock est le minimum requis pour reproduire l‚Äôapplication mais ce n‚Äôest pas un environnement fig√©. Si vous ajoutez des packages utiles pour votre application, avant la phase de mise en production, n‚Äôoubliez pas de faire renv::snapshot() pour mettre √† jour le fichier renv.lock (c‚Äôest le point 1. √©voqu√© pr√©c√©demment).\n\n\n\n\n\n\nCe que renv √©vite\n\n\n\n\n\nOn retrouve parfois sur internet un code similaire √† celui-ci :\n# A ne pas reproduire chez vous üò®\nif (!requireNamespace(\"dplyr\", quietly = TRUE)) {\n  install.packages(\"dplyr\")\n}\nC‚Äôest une gestion artisanale de l‚Äôenvironnement qui n‚Äôest pas conseill√©e. renv sera plus simple et plus fiable. De mani√®re g√©n√©rale, ce n‚Äôest pas une bonne pratique de g√©rer l‚Äôinstallation des packages dans le script. En effet, c‚Äôest un √©l√©ment de configuration et, comme nous l‚Äôavons dit, celle-ci doit se faire en dehors du script.\n\n\n\nMaintenant que nous disposons d‚Äôun environnement fonctionnel, nous pouvons avancer sur la conception du projet. La premi√®re √©tape est d‚Äôexplorer les jeux de donn√©es que nous utiliserons dans l‚Äôapplication.\n\n\nPour faire les choses bien, il faudrait repartir d‚Äôun environnement vierge et installer toutes les d√©pendances du projet (comme le fait la solution ).\nN√©anmoins, si vous √™tes sur le SSPCloud, c‚Äôest presque de l‚Äôexc√®s de z√®le de faire cela car l‚Äôapplication a √©t√© d√©velopp√© √† partir de l‚Äôenvironnement du SSPCloud duquel elle ne diverge que tr√®s peu. Il suffit donc d‚Äôajouter √† l‚Äôenvironnement existant un nombre restreint de packages qui sont list√©s dans requirements.txt.\nDans le terminal, il suffit donc de faire un pip install ad√©quat:\npip install -r requirements.txt\n\n\n\n\n\n\nCe que ce fichier requirements.txt √©vite\n\n\n\n\n\nOn retrouve parfois dans des notebooks partag√©s sur internet un code similaire √† celui-ci :\n# A ne pas reproduire chez vous üò®\n!pip install geopandas\nvoire parfois dans des scripts, ce type de code:\n# A ne pas reproduire chez vous üò®\nimport subprocess\nsubprocess.run([\"pip install geopandas\"]) \nC‚Äôest une gestion artisanale de l‚Äôenvironnement qui n‚Äôest pas conseill√©e. De mani√®re g√©n√©rale, ce n‚Äôest pas une bonne pratique de g√©rer l‚Äôinstallation des packages dans le script. En effet, c‚Äôest un √©l√©ment de configuration et, comme nous l‚Äôavons dit, celle-ci doit se faire en dehors du script."
  },
  {
    "objectID": "index.html#objectifs",
    "href": "index.html#objectifs",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "3.1 Objectifs",
    "text": "3.1 Objectifs\nDans cette partie, vous allez explorer les donn√©es utilis√©es pour construire le tableau de bord, avec trois objectifs:\n\nvous familiariser avec les sources statistiques sur le trafic a√©rien;\nd√©velopper des fonctions permettant d‚Äôimporter automatiquement ces donn√©es;\nd√©couvrir comment vous pouvez organiser ces fonctions pour qu‚Äôelles puissent √™tre facilement utilis√©es par l‚Äôapplication web (spoiler alert: c‚Äôest l√† que le dossier R/ ou src/ va servir)."
  },
  {
    "objectID": "index.html#sources",
    "href": "index.html#sources",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "3.2 Sources",
    "text": "3.2 Sources\nLes sources statistiques utilis√©es dans ce tutoriel sont list√©es dans le fichier sources.yaml. Il y a quatre sources diff√©rentes:\n\nLe trafic au niveau de chaque a√©roport (format CSV);\nLe nombre de passagers pour diff√©rentes liaisons (format CSV);\nLe trafic pour diff√©rentes compagnies (format CSV);\nLes localisations des a√©roports (format geojson).\n\nUne bonne pratique, lorsqu‚Äôon utilise plusieurs sources, est de lister celles-ci dans un fichier YAML plut√¥t que de les inscrire en brut dans le code. Ce dernier sera plus lisible gr√¢ce √† cette approche.\n\n\nVoir le fichier sources.yml\n\n\n\nsources.yml\n\n# Jeux de donn√©es \n# https://www.data.gouv.fr/fr/datasets/trafic-aerien-commercial-mensuel-francais-par-paire-daeroports-par-sens-depuis-1990/\n\nairports:\n  2018: \"https://www.data.gouv.fr/fr/datasets/r/3b7646ea-276c-4c9b-8151-1e96af2adbf9\"\n  2019: \"https://www.data.gouv.fr/fr/datasets/r/e8efa154-045e-4f8f-a1d7-76a39fa03b7b\"\n  2020: \"https://www.data.gouv.fr/fr/datasets/r/6717f107-be00-4b4b-9706-fa0e5190fb69\"\n  2021: \"https://www.data.gouv.fr/fr/datasets/r/2f9f6e54-e2d7-4e85-b811-2e5e68fa5bca\"\n  2022: \"https://www.data.gouv.fr/fr/datasets/r/f1bd931e-c99e-41ce-865e-9e9785c903ec\"\nliaisons:\n  2018: \"https://www.data.gouv.fr/fr/datasets/r/9c5354ad-31cb-4217-bc88-fb7c9be22655\"\n  2019: \"https://www.data.gouv.fr/fr/datasets/r/0c0a451e-983b-4f06-9627-b5ff1bccd2fc\"\n  2020: \"https://www.data.gouv.fr/fr/datasets/r/dad30bed-7276-4a67-a1ab-a856e6e01788\"\n  2021: \"https://www.data.gouv.fr/fr/datasets/r/bbf6492d-86ac-43a0-9260-7df2ffdb5a77\"\n  2022: \"https://www.data.gouv.fr/fr/datasets/r/af8950bc-e90a-4b7e-bb81-70c79d4c3846\"\ncompagnies:\n  2018: \"https://www.data.gouv.fr/fr/datasets/r/ddfea6a0-df7e-4402-99fc-165f573f2e10\"\n  2019: \"https://www.data.gouv.fr/fr/datasets/r/8421e029-c8c7-410d-b38c-54455ac3265d\"\n  2020: \"https://www.data.gouv.fr/fr/datasets/r/818eec10-6122-4788-8233-482e779ab837\"\n  2021: \"https://www.data.gouv.fr/fr/datasets/r/0b954774-ccd1-43ec-9b5a-f958fba03e87\"\n  2022: \"https://www.data.gouv.fr/fr/datasets/r/bcec3e1e-940a-4772-bc28-0d7b2b53c718\"\ngeojson:\n  airport: \"https://minio.lab.sspcloud.fr/projet-funathon/2024/sujet2/aeroports.geojson\""
  },
  {
    "objectID": "index.html#importer-la-liste-des-sources-disponibles",
    "href": "index.html#importer-la-liste-des-sources-disponibles",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "3.3 Importer la liste des sources disponibles",
    "text": "3.3 Importer la liste des sources disponibles\nLes consignes de cet exercice sont quasiment identiques selon le langage car les librairies R et Python pour lire des fichiers YAML portent le m√™me nom.\n\n\n\n\n\n\n Exercice 1: lire les sources dans  et \n\n\n\n\n\n\nLe package R yaml comporte une fonction read_yaml pour transformer un fichier YAML en liste imbriqu√©e; le package Python yaml comporte une fonction safe_load qui fait la m√™me chose. Tester cette fonction sur le fichier sources.yml.\nTransformer ce bout de code en une fonction create_data_list prenant un argument source_file et renvoyant cette liste.\nCr√©er √† la racine du projet un dossier R/ () ou src/ (). Attention, ne confondez pas avec le dossier correction/R/ ou correction/src/ qui contient la correction‚Ä¶\nDans ce nouveau dossier, cr√©ez un script nomm√© create_data_list.R () ou create_data_list.py () et reportez-y la fonction que vous avez cr√©√©e. Dans le cas de Python, ce fichier doit commencer par import yaml, car ce package est utilis√© dans la fonction.\n\n\n\n\n\n\n\n\n\n\nVoir la solution √† cet exercice\n\n#' Creates a 2-levels list of urls, pointing to open source data\n#' \n#' @param source_file yaml file containing data urls \n#' @return list (level 1 = concepts, level 2 = year).\n#'\n#' @examples\n#'  create_data_list(\"sources.yml\")\n#'  \ncreate_data_list &lt;- function(source_file){\n  catalogue &lt;- yaml::read_yaml(source_file)\n  return(catalogue)\n}\n\nLa fonction-solution de cet exercice est dans le fichier correction/R/create_data_list.R. Elle peut √™tre import√©e dans l‚Äôenvironnement global gr√¢ce √† la commande:\n\nsource(\"correction/R/create_data_list.R\")\n\n\n\n\n\nVoir la solution √† cet exercice\n\nimport yaml\n\ndef create_data_list(source_file):\n    \"\"\"\n    Reads a YAML file and returns the contents as a dictionary.\n\n    Args:\n        source_file (str): The path to the YAML file.\n\n    Returns:\n        dict: The contents of the YAML file.\n    \"\"\"\n    with open(source_file, 'r') as file:\n        catalogue = yaml.safe_load(file)\n    return catalogue\n\nLa fonction-solution de cet exercice est dans le fichier correction/src/create_data_list.py.\nUne fois que vous avez cr√©√© et rempli le fichier src/create_data_list.py, vous pouvez importer la fonction create_data_list dans l‚Äôenvironnement global gr√¢ce √† la commande:\nfrom src.create_data_list import create_data_list\n\n\n\nCet exemple simple vous montre ce que sera l‚Äôorganisation finale de l‚Äôapplication: l‚Äôapplication web qui sera construite plus tard dans les fichiers server.R et ui.R () ou app.py () pourra facilement appeler des fonctions utilitaires stock√©es dans R/ ou dans src/. Cette organisation est tr√®s pratique car elle s√©pare l‚Äôapplication web stricto sensu des fonctions g√©n√©riques de manipulation de donn√©es et contribue √† rendre les codes faciles √† comprendre et √† maintenir."
  },
  {
    "objectID": "index.html#importer-les-premi√®res-bases",
    "href": "index.html#importer-les-premi√®res-bases",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "3.4 Importer les premi√®res bases",
    "text": "3.4 Importer les premi√®res bases\nNous pouvons maintenant utiliser cette fonction pour lister tous nos URL des sources.\n\n\n\n\n\nurls &lt;- create_data_list(\"sources.yml\")\n\n\n\nurls = create_data_list(\"sources.yml\")\n\n\n\n\n\n\n\n\n\n Exercice 2: d√©couvrir les diff√©rentes sources\n\n\n\n\n\nDans cet exercice, vous allez d√©couvrir les sources utilis√©es dans le tutoriel et d√©velopper des fonctions g√©n√©riques de traitement de donn√©es qui seront ensuite utilis√©es par l‚Äôapplication web.\n\nDonn√©es a√©roports\n\nLes donn√©es sont des CSV europ√©ens (avec le s√©parateur ;). Il est donc conseill√© d‚Äôutiliser la fonction read_csv2 du package readr pour lire les donn√©es √† partir de la liste de fichiers unlist(urls$airports)4 si vous utilisez , et d‚Äôutiliser la fonction read_csv du package pandas pour lire les donn√©es √† partir de la liste de fichiers list(urls['airports'].values()) si vous utilisez .\nIl est recommand√© de ne pas laisser les types par d√©faut des colonnes mais de figer ceux-ci avec l‚Äôargument suivant:\n\n\n\n\n\ncol_types = cols(\n  ANMOIS = col_character(),\n  APT = col_character(),\n  APT_NOM = col_character(),\n  APT_ZON = col_character(),\n  .default = col_double()\n)\n\n\ndtype = {\n    \"ANMOIS\": \"str\",  \n    \"APT\": \"str\",     \n    \"APT_NOM\": \"str\", \n    \"APT_ZON\": \"str\",\n}\n\n\n\n\nA partir de la variable ANMOIS, cr√©er les variables an et mois. Penser √† enlever les 0 des mois de janvier √† septembre.\n\n\n\nAide si vous √™tes bloqu√© sur cette question\n\n\n\n\n\nPour extraire des √©l√©ments d‚Äôune chaine de caract√®re √† partir de la position, il est recommand√© d‚Äôutiliser la fonction str_sub du package stringr. Pour cr√©er de nouvelles colonnes, il est recommand√© d‚Äôutiliser la fonction mutate du package dplyr.\n\n\n\n\n\n\nConseil pour se faciliter la vie ult√©rieurement\n\n\n\nIl est recommand√© d‚Äôutiliser str_remove pour retirer les z√©ros en d√©but de mois qui pourront nous cr√©er des difficult√©s ult√©rieurement.\n\n\nSi vous √™tes toujours bloqu√©, la solution est donn√©e plus bas üëá\n\n\nVous pouvez utiliser les m√©thodes de donn√©es textuelles str.sub et str.replace de Pandas.\n\n\n\n\n\nCr√©er une fonction clean_dataframe qui prend en entr√©e un dataframe, cr√©e les variables an et mois, ajoute une √©tape de passage des noms de colonne en minuscule et renvoie le dataframe en sortie.\n\n\n\nSolution\n\n\n\n\n\nclean_dataframe &lt;- function(df){\n  \n  # Create an et mois columns\n  df &lt;- df %&gt;% \n    mutate(\n      an = str_sub(ANMOIS,1,4),\n      mois = str_sub(ANMOIS,5,6)\n    ) %&gt;%\n    mutate(\n      mois = str_remove(mois, \"^0+\")\n    )\n  \n  # lower case for variable names\n  colnames(df) &lt;- tolower(colnames(df))\n  \n  return(df)\n\n}\n\n\ndef clean_dataframe(df):\n    # Create 'an' and 'mois' columns\n    df['an'] = df['ANMOIS'].astype(str).str[:4]\n    df['mois'] = df['ANMOIS'].astype(str).str[-2:]\n\n    # Remove leading zeros from 'mois' column\n    df['mois'] = df['mois'].str.replace(r'^0+', '', regex=True)\n\n    # Convert all column names to lowercase\n    df.columns = df.columns.str.lower()\n\n    return df\n\n\n\n\n\nCr√©er une fonction import_airport_data qui prend en input list_files et int√®gre les deux √©tapes pr√©c√©dentes: la lecture des donn√©es, le nettoyage avec clean_dataframe. Dans le cas de Python, ne pas oublier de concat√©ner les diff√©rentes tables avec pd.concat.\n\n\n\nSolution\n\n\n\n\n\nimport_airport_data &lt;- function(list_files){\n  \n  pax_apt_all &lt;- readr::read_csv2(\n    list_files, \n    col_types = cols(\n      ANMOIS = col_character(),\n      APT = col_character(),\n      APT_NOM = col_character(),\n      APT_ZON = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_apt_all)\n  \n}\n\nReporter cette fonction dans un fichier R/clean_dataframe.R et faire\n\nsource(\"R/clean_dataframe.R\")\n\n\nimport pandas as pd\nfrom .clean_dataframe import clean_dataframe\n\ndef import_airport_data(list_files):\n    # Define the data types for each column\n    col_types = {\n        \"ANMOIS\": \"str\",\n        \"APT\": \"str\",     # equivalent to col_character()\n        \"APT_NOM\": \"str\", # equivalent to col_character()\n        \"APT_ZON\": \"str\", # equivalent to col_character()\n    }\n\n    # Read the CSV file(s) with the specified column types\n    pax_apt_all = pd.concat([\n        pd.read_csv(file, delimiter = ';', dtype = col_types)\n        for file in list_files\n        ])\n\n    # Clean the DataFrame (assuming clean_dataframe is a predefined function)\n    pax_apt_all = clean_dataframe(pax_apt_all)\n\n    return pax_apt_all\n\nReporter cette fonction dans un fichier src/clean_dataframe.py et faire\n\nfrom src.clean_dataframe import clean_dataframe\n\n\n\n\n\n\nDonn√©es compagnies\nSur le m√™me principe, cr√©er une fonction import_compagnies_data qui effectue la m√™me suite d‚Äôop√©rations. Faire n√©anmoins attention aux types des colonnes.\n\n\n\n\n\n\nRecommandation de param√®tre pour read_csv2 pour l‚Äôimport de ces fichiers\ncol_types = cols(\n  ANMOIS = col_character(),\n  CIE = col_character(),\n  CIE_NOM = col_character(),\n  CIE_NAT = col_character(),\n  CIE_PAYS = col_character(),\n  .default = col_double()\n)\n\n\n\n\nSolution\n\nimport_compagnies_data &lt;- function(list_files){\n  \n  pax_cie_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      CIE = col_character(),\n      CIE_NOM = col_character(),\n      CIE_NAT = col_character(),\n      CIE_PAYS = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_cie_all)\n  \n  \n}\n\n\n\nRecommandation de param√®tre pour read_csv pour l‚Äôimport de ces fichiers\ncol_types = {\n  ANMOIS = \"str\",\n  CIE = \"str\",\n  CIE_NOM = \"str\",\n  CIE_NAT = \"str\",\n  CIE_PAYS = \"str\"\n}\n\n\nSolution\n\ndef import_compagnies_data(list_files):\n    # Define the data types for each column\n    col_types = {\n        \"ANMOIS\": \"str\",\n        \"CIE\": \"str\",\n        \"CIE_NOM\": \"str\",\n        \"CIE_NAT\": \"str\",\n        \"CIE_PAYS\": \"str\"\n    }\n\n    # Read the CSV file(s) with the specified column types\n    pax_cie_all = pd.concat([\n        pd.read_csv(file, delimiter = ';', dtype = col_types)\n        for file in list_files\n        ])\n\n    # Clean the DataFrame (assuming clean_dataframe is a predefined function)\n    pax_cie_all = clean_dataframe(pax_cie_all)\n\n\n    return pax_cie_all\n\n\n\n\n\n\nDonn√©es liaisons\nSur le m√™me principe, cr√©er une fonction import_liaisons_data qui effectue la m√™me suite d‚Äôop√©rations. Faire n√©anmoins attention aux types des colonnes.\n\n\n\n\n\n\nRecommandation de param√®tre pour read_csv pour l‚Äôimport de ces fichiers\ncol_types = cols(\n  ANMOIS = col_character(),\n  LSN = col_character(),\n  LSN_DEP_NOM = col_character(),\n  LSN_ARR_NOM = col_character(),\n  LSN_SCT = col_character(),\n  LSN_FSC = col_character(),\n  .default = col_double()\n)\n\n\n\n\nSolution\n\nimport_liaisons_data &lt;- function(list_files){\n  \n  pax_lsn_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      LSN = col_character(),\n      LSN_DEP_NOM = col_character(),\n      LSN_ARR_NOM = col_character(),\n      LSN_SCT = col_character(),\n      LSN_FSC = col_character(),\n      .default = col_double()\n    ) \n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_lsn_all)\n  \n  \n}\n\n\n\nConseil pour les colonnes:\ncol_types = {\n  \"ANMOIS\": \"str\",\n  \"LSN\": \"str\",\n  \"LSN_DEP_NOM\": \"str\",\n  \"LSN_ARR_NOM\": \"str\",\n  \"LSN_SCT\": \"str\",\n  \"LSN_FSC\": \"str\"\n}\n\n\nSolution\n\ndef import_liaisons_data(list_files):\n    # Define the data types for each column\n    col_types = {\n        \"ANMOIS\": \"str\",\n        \"LSN\": \"str\",\n        \"LSN_DEP_NOM\": \"str\",\n        \"LSN_ARR_NOM\": \"str\",\n        \"LSN_SCT\": \"str\",\n        \"LSN_FSC\": \"str\"\n    }\n\n    # Read the CSV file(s) with the specified column types\n    pax_lsn_all = pd.concat([\n        pd.read_csv(file, delimiter = ';', dtype = col_types)\n        for file in list_files\n        ])\n\n    # Clean the DataFrame\n    pax_lsn_all = clean_dataframe(pax_lsn_all)\n\n    return pax_lsn_all\n\n\n\n\n\n\nConstruction de fichiers de fonctions\n\nReporter la fonction clean_dataframe dans un fichier R/clean_dataframe.R () ou topinambour/clean_dataframe.py ().\nReporter les fonctions import_airport_data, import_compagnies_data et import_liaisons_data dans un fichier R/import_data.R () ou scr/import_data.py (). Dans le cas de Python, le fichier devra commencer par ceci:\n\nimport pandas as pd\nfrom .clean_dataframe import clean_dataframe\n\n\n\n\nA l‚Äôissue de cette partie, vous devriez avoir le fichier R/import_data.R suivant\n\n\nLe fichier R/import_data.R attendu\n\n\n\nR/import_data.R\n\nimport_airport_data &lt;- function(list_files){\n  \n  pax_apt_all &lt;- readr::read_csv2(\n    list_files, \n    col_types = cols(\n      ANMOIS = col_character(),\n      APT = col_character(),\n      APT_NOM = col_character(),\n      APT_ZON = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_apt_all)\n  \n}\n\n\nimport_compagnies_data &lt;- function(list_files){\n  \n  pax_cie_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      CIE = col_character(),\n      CIE_NOM = col_character(),\n      CIE_NAT = col_character(),\n      CIE_PAYS = col_character(),\n      .default = col_double()\n    )\n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_cie_all)\n  \n  \n}\n\n\nimport_liaisons_data &lt;- function(list_files){\n  \n  pax_lsn_all &lt;- readr::read_csv2(\n    file = list_files,\n    col_types = cols(\n      ANMOIS = col_character(),\n      LSN = col_character(),\n      LSN_DEP_NOM = col_character(),\n      LSN_ARR_NOM = col_character(),\n      LSN_SCT = col_character(),\n      LSN_FSC = col_character(),\n      .default = col_double()\n    ) \n  ) %&gt;% \n    clean_dataframe()\n  \n  return(pax_lsn_all)\n  \n  \n}\n\n\n\n\nA l‚Äôissue de cette partie, vous devriez avoir le fichier src/import_data.py suivant\n\n\nLe fichier src/import_data.py attendu\n\n\n\nsrc/import_data.py\n\nimport pandas as pd\nfrom .clean_dataframe import clean_dataframe\n\ndef import_airport_data(list_files):\n    # Define the data types for each column\n    col_types = {\n        \"ANMOIS\": \"str\",\n        \"APT\": \"str\",     # equivalent to col_character()\n        \"APT_NOM\": \"str\", # equivalent to col_character()\n        \"APT_ZON\": \"str\", # equivalent to col_character()\n    }\n\n    # Read the CSV file(s) with the specified column types\n    pax_apt_all = pd.concat([\n        pd.read_csv(file, delimiter = ';', dtype = col_types)\n        for file in list_files\n        ])\n\n    # Clean the DataFrame (assuming clean_dataframe is a predefined function)\n    pax_apt_all = clean_dataframe(pax_apt_all)\n\n    return pax_apt_all\n\n\n\ndef import_compagnies_data(list_files):\n    # Define the data types for each column\n    col_types = {\n        \"ANMOIS\": \"str\",\n        \"CIE\": \"str\",\n        \"CIE_NOM\": \"str\",\n        \"CIE_NAT\": \"str\",\n        \"CIE_PAYS\": \"str\"\n    }\n\n    # Read the CSV file(s) with the specified column types\n    pax_cie_all = pd.concat([\n        pd.read_csv(file, delimiter = ';', dtype = col_types)\n        for file in list_files\n        ])\n\n    # Clean the DataFrame (assuming clean_dataframe is a predefined function)\n    pax_cie_all = clean_dataframe(pax_cie_all)\n\n\n    return pax_cie_all\n\n\ndef import_liaisons_data(list_files):\n    # Define the data types for each column\n    col_types = {\n        \"ANMOIS\": \"str\",\n        \"LSN\": \"str\",\n        \"LSN_DEP_NOM\": \"str\",\n        \"LSN_ARR_NOM\": \"str\",\n        \"LSN_SCT\": \"str\",\n        \"LSN_FSC\": \"str\"\n    }\n\n    # Read the CSV file(s) with the specified column types\n    pax_lsn_all = pd.concat([\n        pd.read_csv(file, delimiter = ';', dtype = col_types)\n        for file in list_files\n        ])\n\n    # Clean the DataFrame\n    pax_lsn_all = clean_dataframe(pax_lsn_all)\n\n    return pax_lsn_all\n\n\n\n\n\n\n\nLocalisations des a√©roports\nIl s‚Äôagit d‚Äôun jeu de donn√©es spatial. Pour en savoir plus sur ce type de donn√©es, il est recommand√© de consulter :\n\nPour les utilisateurs de : la fiche utilitR sur le sujet ou ce cours introductif.\nPour les utilisateurs de : ce chapitre du cours de Python de l‚ÄôENSAE.\n\n\n\n\n\n\nUtiliser la fonction st_read du package sf pour lire ces donn√©es (dont la localisation est stock√©e dans la variable urls$geojson$airport). Stocker l‚Äôobjet obtenu sous le nom airports_location\n\n\n\n\nUtiliser la fonction read_file du package geopandas pour lire ces donn√©es (dont la localisation est stock√©e dans la variable urls['geojson']['airport']). Stocker l‚Äôobjet obtenu sous le nom airports_location\n\n\n\n\n\nV√©rifier que les donn√©es sont bien dans le syst√®me de repr√©sentation WGS 845\n\n\n\nAide\n\nLa fonction √† utiliser est sf_crs  ou l‚Äôattribut crs pour \n\n\nIl est toujours utile de v√©rifier que nos donn√©es sont bien localis√©es o√π on les attend. Pour cela, il est pertinent de faire une carte avec un fond de carte contextuel, m√™me si celle-ci n‚Äôest pas tr√®s soign√©e. Pour faire ceci, le plus simple est d‚Äôutiliser la librairie Javascript Leaflet. L‚Äôusage n‚Äôest pas exactement le m√™me en R et en Python:\n\n\nla fonction addMarkers du package leaflet ();\nles fonctions Map et add_to du package folium ().\n\nEssayez de faire cette carte vous-m√™mes ou consultez l‚Äôaide ci-dessous\n\n\nCode pour faire une carte leaflet minimale\n\n# En R\nleaflet(airports_location) %&gt;%\n  addTiles() %&gt;%\n  addMarkers(popup = ~Nom)\n# En Python\nimport folium \nm = folium.Map()\n\nfolium.GeoJson(airports_location).add_to(m)\nm\n\n\n\n\n\nLa carte leaflet que vous devriez avoir obtenue √† la fin de l‚Äôexercice est la suivante:\n\nleaflet(airports_location) %&gt;%\n  addTiles() %&gt;%\n  addMarkers(popup = ~Nom)\n\n\n\n\n\n\n\n\n\nA l‚Äôissue de l‚Äôexercice, le code centralis√© dans le script R/import_data.R peut √™tre import√© via le code suivant\n\nsource(\"R/import_data.R\")\n\nVous pouvez initier un script nomm√© main.R avec les lignes suivante:\n\n\nmain.R\n\nMONTHS_LIST = 1:12\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nen les faisant pr√©c√©der de l‚Äôimport des scripts que nous avons d√©j√† cr√©√©s dans le dossier R:\nsource(\"R/create_data_list.R\")\nsource(\"R/import_data.R\")  \nsource(\"R/clean_dataframe.R\")\nUne bonne pratique est de tester son script dans une session vierge. Cela am√®ne √† construire pas √† pas une chaine plus reproductible. Pour cela,\n\nAller dans les options de  via Tools &gt; Global Options et d√©cocher la case Restore .RData into workspace at setup\nRed√©marrer votre session  via le menu Session &gt; Restart R ou le raccourci CTRL+SHIFT+F10\nEx√©cuter votre fichier main.R. Vous devriez rencontrer des erreurs car nous n‚Äôavons pas g√©r√© les import de librairies dans ce script puisque notre session actuelle ne b√©n√©ficie plus des import ant√©rieurs.\n\nUne bonne pratique pour comprendre cette exigence de reproductibilit√© est d‚Äôit√©rativement ajouter les librairies utiles √† mesure qu‚Äôon rencontre des erreurs (notre code √©tant tr√®s rapide √† tourner, cette logique d‚Äôessai-erreur n‚Äôest pas tr√®s co√ªteuse). Si vous ne d√©sirez pas faire ceci (dommage, c‚Äôest un bon exercice), vous pouvez trouver les imports de packages √† faire pour que notre script soit reproductible.\n\n\nL‚Äôenvironnement minimal de reproductibilit√© pour que le script main.R fonctionne\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\n\nCes librairies sont √† √©crire au d√©but de main.R.\n\n\nA l‚Äôissue de l‚Äôexercice, le code centralis√© dans le script src/import_data.py peut √™tre import√© via le code suivant\nimport src.import_data as sid"
  },
  {
    "objectID": "index.html#objectifs-1",
    "href": "index.html#objectifs-1",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "4.1 Objectifs",
    "text": "4.1 Objectifs\nDans cette partie, vous allez exploiter les donn√©es pour produire trois valorisations qui seront ensuite int√©gr√©es dans l‚Äôapplication web:\n\nun graphique dynamique pr√©sentant le trafic pour un a√©roport donn√©;\nun tableau HTML affichant des donn√©es sur le trafic;\nune carte des a√©roports.\n\nUne fois que ces valorisations seront pr√™tes, nous pourrons nous pencher sur leur int√©gration dans une application interactive."
  },
  {
    "objectID": "index.html#pr√©requis-cr√©er-le-script-main",
    "href": "index.html#pr√©requis-cr√©er-le-script-main",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "4.2 Pr√©requis: cr√©er le script main",
    "text": "4.2 Pr√©requis: cr√©er le script main\nPour commencer, vous allez cr√©er un fichier fichier main.R () ou main.py () √† la racine du d√©p√¥t. Ensuite, vous pouvez y copier le code suivant.\n\n\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(plotly)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/figures.R\")\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\nimport pandas as pd\nimport geopandas as gpd\nimport plotly.express as px\nfrom plotnine import ggplot, geom_line, aes\n\nimport src.import_data as sid\nfrom src.create_data_list import create_data_list\n\n# Load data ----------------------------------\nurls = create_data_list(\"./sources.yml\")\n\n\npax_apt_all = sid.import_airport_data(urls['airports'].values())\npax_cie_all = sid.import_airport_data(urls['compagnies'].values())\npax_lsn_all = sid.import_airport_data(urls['liaisons'].values())\n\n\nairports_location = gpd.read_file(\n    urls['geojson']['airport']\n)\n\n\nliste_aeroports = pax_apt_all['apt'].unique()\ndefault_airport = liste_aeroports[0]"
  },
  {
    "objectID": "index.html#valorisation-1-le-trafic-par-a√©roport",
    "href": "index.html#valorisation-1-le-trafic-par-a√©roport",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "4.3 Valorisation 1: Le trafic par a√©roport",
    "text": "4.3 Valorisation 1: Le trafic par a√©roport\nLa premi√®re valorisation qui sera int√©gr√©e dans l‚Äôapplication web est un graphique d√©crivant le trafic a√©rien au niveau d‚Äôun a√©roport.\nDans le prochain exercice, nous proposons d‚Äôabord de cr√©er une figure minimale (avec ggplot  ou son √©quivalent  plotnine) pour v√©rifier que nos donn√©es ont bien la dimension temporelle attendue. Cependant, comme Shiny est un syst√®me interactif, on privil√©giera la librairie Plotly pour faire des figures: il s‚Äôagit d‚Äôune librairie Javascript qui peut √™tre appel√©e gr√¢ce √† des librairies clientes en  ou .\n\n\n\n\n\n\n Exercice 3: Produire un graphique de fr√©quentation des a√©roports\n\n\n\n\n\nDans le script main.R ou main.py:\n\nCr√©er une variable trafic √©gale apt_pax_dep + apt_pax_tr + apt_pax_arr;\nNe conserver que les donn√©es relatives √† l‚Äôa√©roport default_airport;\nCr√©er une variable date qui utilise les colonnes an et mois. Cette variable de date doit √™tre au format date, pas au format chr.\n\n\n\nEncha√Ænement des op√©rations attendues √† cette √©tape\n\n\n\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(plotly)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/figures.R\")\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\n\nimport pandas as pd\nimport geopandas as gpd\nimport plotly.express as px\nfrom plotnine import ggplot, geom_line, aes\n\nimport src.import_data as sid\nfrom src.create_data_list import create_data_list\n\n# Load data ----------------------------------\nurls = create_data_list(\"./sources.yml\")\n\n\npax_apt_all = sid.import_airport_data(urls['airports'].values())\npax_cie_all = sid.import_airport_data(urls['compagnies'].values())\npax_lsn_all = sid.import_airport_data(urls['liaisons'].values())\n\n\nairports_location = gpd.read_file(\n    urls['geojson']['airport']\n)\n\n\nliste_aeroports = pax_apt_all['apt'].unique()\ndefault_airport = liste_aeroports[0]\n\n\npax_apt_all['trafic'] = pax_apt_all['apt_pax_dep'] + \\\n  pax_apt_all['apt_pax_tr'] + \\\n  pax_apt_all['apt_pax_arr']\n\ntrafic_aeroports = (\n  pax_apt_all\n  .loc[pax_apt_all['apt'] == default_airport]\n)\ntrafic_aeroports['date'] = pd.to_datetime(\n  trafic_aeroports['anmois'] + '01', format='%Y%m%d'\n)\n\n\n\n\n\nFaire une figure statique pour observer la dynamique des donn√©es:\n\n\nPour les utilisateurs de , ce sera bien s√ªr avec ggplot ;\nPour les utilisateurs de , vous pouvez utiliser le module graphique de votre choix: matplotlib, seaborn ou plotnine. Nous recommandons n√©anmoins plotnine, la transposition en  de la grammaire des graphiques ggplot.\n\nVous devriez obtenir une figure similaire √† celle-ci:\n\n\n\n\n\nIl est inutile d‚Äôaller plus loin sur la mise en forme de cette figure, car l‚Äôapplication interactive comportera in fine des figures dynamiques (qui se modifient en fonction des demandes de l‚Äôutilisateur) plut√¥t que des figures statiques comme celle que vous venez de produire.\n\nNous allons maintenant faire une figure dynamique avec la librairie Plotly. Pour cela, vous pouvez vous inspirer de cette page () ou celle-ci (). La figure que vous devriez avoir est la suivante:\n\n\n\n\n\n\n\n\n\nAide: le code pour g√©n√©rer la figure\n\n\n\n\n\nfigure_ggplot &lt;- trafic_aeroports %&gt;%\n  ggplot(.) + geom_line(aes(x = date, y = trafic))\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports, default_airport)\n\n\nfigure_plotly = px.line(\n  trafic_aeroports, x=\"date\", y=\"trafic\",\n  text=\"apt_nom\"\n)\n\nfigure_plotly.update_traces(\n  mode=\"markers+lines\", type = \"scatter\",\n  hovertemplate=\"&lt;i&gt;A√©roport:&lt;/i&gt; %{text}&lt;br&gt;Trafic: %{y}\"\n)\n\n\n\n\n\n\n\nLe code complet pour r√©pliquer cet exercice est donn√© ci-dessous.\n\n\nCode de l‚Äôexercice\n\n\n\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(plotly)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/figures.R\")\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_ggplot &lt;- trafic_aeroports %&gt;%\n  ggplot(.) + geom_line(aes(x = date, y = trafic))\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports, default_airport)\n\n\nimport pandas as pd\nimport geopandas as gpd\nimport plotly.express as px\nfrom plotnine import ggplot, geom_line, aes\n\nimport src.import_data as sid\nfrom src.create_data_list import create_data_list\n\n# Load data ----------------------------------\nurls = create_data_list(\"./sources.yml\")\n\n\npax_apt_all = sid.import_airport_data(urls['airports'].values())\npax_cie_all = sid.import_airport_data(urls['compagnies'].values())\npax_lsn_all = sid.import_airport_data(urls['liaisons'].values())\n\n\nairports_location = gpd.read_file(\n    urls['geojson']['airport']\n)\n\n\nliste_aeroports = pax_apt_all['apt'].unique()\ndefault_airport = liste_aeroports[0]\n\n\npax_apt_all['trafic'] = pax_apt_all['apt_pax_dep'] + \\\n  pax_apt_all['apt_pax_tr'] + \\\n  pax_apt_all['apt_pax_arr']\n\ntrafic_aeroports = (\n  pax_apt_all\n  .loc[pax_apt_all['apt'] == default_airport]\n)\ntrafic_aeroports['date'] = pd.to_datetime(\n  trafic_aeroports['anmois'] + '01', format='%Y%m%d'\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_ggplot = (\n    ggplot(trafic_aeroports) +\n    geom_line(aes(x = \"date\", y = \"trafic\"))\n)\n\n\nfigure_plotly = px.line(\n  trafic_aeroports, x=\"date\", y=\"trafic\",\n  text=\"apt_nom\"\n)\n\nfigure_plotly.update_traces(\n  mode=\"markers+lines\", type = \"scatter\",\n  hovertemplate=\"&lt;i&gt;A√©roport:&lt;/i&gt; %{text}&lt;br&gt;Trafic: %{y}\"\n)\n\n\n\n\nNous proposons de le transformer en fonction, ce sera plus simple √† int√©grer ult√©rieurement dans notre application\n\n\n\n\n\n\n Exercice 3b: une fonction de production graphique\n\n\n\n\n\nTransformer le code ci-dessus en une fonction nomm√©e plot_airport_line afin que:\n\nles inputs soient les suivants: un dataframe et un a√©roport √† s√©lectionner;\nla sortie soit notre figure plotly.\n\nTester la fonction sur d‚Äôautres a√©roports de la liste. Quand vous √™tes satisfaits de celle-ci, d√©placer la d√©finition de cette fonction dans R/figures.R () ou src/figures.py ().\n\n\n\n\n\n\n\n\n\nFichier R/figures.R √† l‚Äôissue de cet exercice\n\n\n\nR/figures.R\n\n\nplot_airport_line &lt;- function(df, selected_airport){\n  trafic_aeroports &lt;- df %&gt;%\n    mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n    filter(apt %in% selected_airport) %&gt;%\n    mutate(\n      date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n    )\n  \n  figure_plotly &lt;- trafic_aeroports %&gt;%\n    plot_ly(\n      x = ~date, y = ~trafic,\n      text = ~apt_nom,\n      hovertemplate = paste(\"&lt;i&gt;A√©roport:&lt;/i&gt; %{text}&lt;br&gt;Trafic: %{y}\") ,\n      type = 'scatter', mode = 'lines+markers')\n  \n  return(figure_plotly)\n}\n\n\nPar la suite, nous pouvons ajouter la ligne suivante au d√©but de notre fichier main.R:\n\nsource(\"R/figures.R\")\n\net utiliser cette fonction √† la fin du fichier.\n\n\nPar la suite, nous pouvons ajouter la ligne suivante au d√©but de notre fichier main.py:\nfrom src.figures import plot_airport_line\net utiliser cette fonction √† la fin du fichier.\n\n\nFichier main.py √† l‚Äôissue de cet exercice\n\n\n\nmain.py\n\nimport pandas as pd\nimport geopandas as gpd\nimport plotly.express as px\nfrom plotnine import ggplot, geom_line, aes\n\nimport src.import_data as sid\nfrom src.create_data_list import create_data_list\n\n# Load data ----------------------------------\nurls = create_data_list(\"./sources.yml\")\n\n\npax_apt_all = sid.import_airport_data(urls['airports'].values())\npax_cie_all = sid.import_airport_data(urls['compagnies'].values())\npax_lsn_all = sid.import_airport_data(urls['liaisons'].values())\n\n\nairports_location = gpd.read_file(\n    urls['geojson']['airport']\n)\n\n\nliste_aeroports = pax_apt_all['apt'].unique()\ndefault_airport = liste_aeroports[0]\n\n\npax_apt_all['trafic'] = pax_apt_all['apt_pax_dep'] + \\\n  pax_apt_all['apt_pax_tr'] + \\\n  pax_apt_all['apt_pax_arr']\n\ntrafic_aeroports = (\n  pax_apt_all\n  .loc[pax_apt_all['apt'] == default_airport]\n)\ntrafic_aeroports['date'] = pd.to_datetime(\n  trafic_aeroports['anmois'] + '01', format='%Y%m%d'\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfrom src.figures import plot_airport_line\n\nfigure_plotly = plot_airport_line(trafic_aeroports, default_airport)"
  },
  {
    "objectID": "index.html#valorisation-2-tableau-html-pour-afficher-des-donn√©es",
    "href": "index.html#valorisation-2-tableau-html-pour-afficher-des-donn√©es",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "4.4 Valorisation 2: Tableau HTML pour afficher des donn√©es",
    "text": "4.4 Valorisation 2: Tableau HTML pour afficher des donn√©es\nLa deuxi√®me valorisation qui sera int√©gr√©e dans l‚Äôapplication web est un tableau permettant de visualiser certaines donn√©es directement dans le dashboard. Il existe plusieurs packages pour faire cela, que ce soit en  ou .\nL‚Äô√©cosyst√®me le plus complet pour faire cela est d√©velopp√© par Posit et est quasi √©quivalent qu‚Äôon fasse du  ou du  (il est plus complet en  car plus ancien dans ce langage). Il s‚Äôagit du package GT () ou Great Tables (). En peu de temps, ces packages sont devenus incontournables et proposent des fonctionnalit√©s bien plus compl√®tes que les solutions qui existaient par le pass√©, notamment DT.\nPour le prochain exercice, vous pourrez utiliser ces objets\n\n\n\n\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\n\n\n\nYEARS_LIST = [str(year) for year in range(2018, 2023)]\nMONTHS_LIST = list(range(1, 13))\n\n\n\n\n\n\n\n\n\n Exercice 4a: pr√©parer les donn√©es avant de faire un beau tableau\n\n\n\n\n\nNous allons int√©grer dans notre application deux tableaux de statistiques descriptives.\n\nChoisir un mois et une ann√©e √† partir des objets YEARS_LIST et MONTHS_LIST pour faire un filtre sur le dataframe pax_apt_all. Une fois que vous √™tes satisfaits, transformer cela en fonction create_data_from_input prenant en argument un dataframe, une ann√©e et un mois\n\n\n\n\n\n\n\nCode de l‚Äôexercice\n\ncreate_data_from_input &lt;- function(data, years, months){\n  data &lt;- data %&gt;%\n    filter(mois %in% months, an %in% years)\n  return(data)\n}\n\n\n\n\n\n\nCode de l‚Äôexercice\n\n\n\n\n\n\n\nPour chaque a√©roport, calculer le nombre total de passager. Puis classer les a√©rports du plus fr√©quent√© au moins fr√©quent√©. Une fois que vous √™tes satisfaits de votre chaine d‚Äôop√©ration, cr√©er une fonction summary_stat_airport.\n\n\n\n\n\n\n\nCode de l‚Äôexercice\n\n  table2 &lt;- data %&gt;%\n    group_by(apt, apt_nom) %&gt;%\n    summarise(\n      paxdep = round(sum(apt_pax_dep, na.rm = T),3),\n      paxarr = round(sum(apt_pax_arr, na.rm = T),3),\n      paxtra = round(sum(apt_pax_tr, na.rm = T),3)) %&gt;%\n    arrange(desc(paxdep)) %&gt;%\n    ungroup()\n  \n  return(table2)\n}\n\nsummary_stat_liaisons &lt;- function(data){\n  agg_data &lt;- data %&gt;%\n    group_by(lsn_fsc) %&gt;%\n    summarise(\n      paxloc = round(sum(lsn_pax_loc, na.rm = TRUE)*1e-6,3)\n    ) %&gt;%\n    ungroup()\n  return(agg_data)\n}\n\n\n\n\n\n\nCode de l‚Äôexercice\n\n\n\n\n\n\nReporter les fonctions cr√©√©es dans cet exercice dans un script R/divers_functions.R () ou src/divers_functions.py. Enrichir le script main.R (resp. main.py) pour utiliser celles-ci en cr√©ant les dataframes ad√©quats (correction ci-dessous)\n\n\n\nVoici une proposition de script main.R (resp. main.py) √† l‚Äôissue de cet exercice\n\n\n\n\n\n\nCode de l‚Äôexercice\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(leaflet)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/divers_functions.R\")\nsource(\"correction/R/figures.R\")\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\nyear &lt;- YEARS_LIST[1]\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\n\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\n\n\n\n\n\nCode de l‚Äôexercice\n\nimport pandas as pd\nimport geopandas as gpd\nimport plotly.express as px\nfrom plotnine import ggplot, geom_line, aes\n\nimport src.import_data as sid\nfrom src.create_data_list import create_data_list\nfrom src.divers_functions import (\n  create_data_from_input,\n  summary_stat_airport\n)\n\nYEARS_LIST = [str(year) for year in range(2018, 2023)]\nMONTHS_LIST = list(range(1, 13))\nyear = YEARS_LIST[0]\nmonth = MONTHS_LIST[0]\n\n# Load data ----------------------------------\nurls = create_data_list(\"./sources.yml\")\n\n\npax_apt_all = sid.import_airport_data(urls['airports'].values())\npax_cie_all = sid.import_airport_data(urls['compagnies'].values())\npax_lsn_all = sid.import_airport_data(urls['liaisons'].values())\n\n\nairports_location = gpd.read_file(\n    urls['geojson']['airport']\n)\n\n\nliste_aeroports = pax_apt_all['apt'].unique()\ndefault_airport = liste_aeroports[0]\n\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\npax_apt_all['trafic'] = pax_apt_all['apt_pax_dep'] + \\\n  pax_apt_all['apt_pax_tr'] + \\\n  pax_apt_all['apt_pax_arr']\n\ntrafic_aeroports = (\n  pax_apt_all\n  .loc[pax_apt_all['apt'] == default_airport]\n)\ntrafic_aeroports['date'] = pd.to_datetime(\n  trafic_aeroports['anmois'] + '01', format='%Y%m%d'\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfrom src.figures import plot_airport_line\n\n\n\nfigure_plotly = px.line(\n  trafic_aeroports, x=\"date\", y=\"trafic\",\n  text=\"apt_nom\"\n)\n\nfigure_plotly.update_traces(\n  mode=\"markers+lines\", type = \"scatter\",\n  hovertemplate=\"&lt;i&gt;A√©roport:&lt;/i&gt; %{text}&lt;br&gt;Trafic: %{y}\"\n)\n\n\n\n\nNous avons maintenant tous les ingr√©dients pour faire un tableau de statistiques descriptives lisibles et esth√©tiques. Avant de cr√©er cette table, nous allons cr√©er une colonne suppl√©mentaire:\n\n\n\n\n\nstats_aeroports_table &lt;- stats_aeroports %&gt;%\n  mutate(name_clean = paste0(str_to_sentence(apt_nom), \" _(\", apt, \")_\")\n) %&gt;%\nselect(name_clean, everything())\n\n\n\nstats_aeroports['name_clean'] = stats_aeroports['apt_nom'].str.title() + \" _(\" + stats_aeroports['apt'] + \")_\"\nstats_aeroports = stats_aeroports[ ['name_clean'] + [ col for col in stats_aeroports.columns if col != 'name_clean' ] ]\n\n\n\nCelle-ci nous permettra, une fois mise en forme, d‚Äôavoir une colonne plus esth√©tique.\n\n\n\n\n\n\n Exercice 4b: un beau tableau (enfin !)\n\n\n\n\n\nLes diff√©rentes questions vont permettre de construire et formatter progressivement notre tableau. Si vous √™tes bloqu√©s, les r√©ponses sont ci-dessous dans des menus d√©roulants.\n\nEn premier lieu, utiliser GT pour faire un tableau basique sur le dataframe stats_aeroports (pour les utilisateurs de , le faire sur stats_aeroports.head(15) car il n‚Äôest pas encore possible de limiter la taille de la page). N‚Äôutiliser aucune option, celles-ci vont √™tre progressivement ajout√©es.\nRetirer les colonnes apt et apt_nom de notre table.\n\n\n\nIl y a plusieurs mani√®res de faire, voici un indice sur la ‚Äúmeilleure‚Äù\n\n\nEn , il est possible d‚Äôutiliser des fonctions de s√©lection de colonnes issues du tidyverse dans GT, notamment la fonction starts_with (√† ne pas confondre avec celle de stringr)\nEn , quand on fournit un DataFrame Polars, on peut utiliser les fonctions de s√©lection qui ressemblent √† celles du tidyverse. N√©anmoins, l√† nous avons un DataFrame Pandas. Il faudra donc utiliser des m√©thodes Pandas, un peu plus verbeuses, du type\n\nstats_aeroports.filter(like = \"&lt;debut_de_string&gt;\").columns.tolist()\n\n\nFormatter les colonnes num√©riques (pour la s√©lection des colonnes num√©riques, voir l‚Äôindice ci-dessus). En consultant la documentation de gt, appliquer l‚Äôoption qui permet de rendre plus concise la notation des milliers (K) et millions (M).\nUtiliser fmt_markdown pour appliquer une mise en forme adapt√©e √† la colonne name_clean\nMettre en forme les noms de colonne (cols_labels), le titre (tab_header), les notes (tab_source_note) pour avoir un tableau esth√©thique et informatif. Pour les utilisateurs de , vous pouvez aussi modifier la couleur de la partie sup√©rieure du tableau (tab_style).\nPour les utilisateurs de , transformer la table en tableau interactif avec opt_interactive6.\n\n\n\n\nLes r√©ponses aux diff√©rentes questions sont donn√©es de mani√®re successives ci-dessous. La table finale, obtenue √† l‚Äôissue de l‚Äôexercice est la suivante:\n\n\n\n\n\n\nR√©ponse question 1\nlibrary(gt)\ntable_aeroports &lt;- gt(stats_aeroports_table)\ntable_aeroports\n\n\n\n\nR√©ponse question 2\ntable_aeroports &lt;- table_aeroports %&gt;%\n  cols_hide(columns = starts_with(\"apt\"))\ntable_aeroports\n\n\n\n\nR√©ponse question 3\ntable_aeroports &lt;- table_aeroports %&gt;%\n  fmt_number(columns = starts_with(\"pax\"), suffixing = TRUE)\ntable_aeroports\n\n\n\n\nR√©ponse question 4\ntable_aeroports &lt;- table_aeroports %&gt;%\n  fmt_markdown(columns = \"name_clean\")\ntable_aeroports\n\n\n\n\nR√©ponse question 5\ntable_aeroports &lt;- table_aeroports %&gt;%\n  cols_label(\n    name_clean = md(\"**A√©roport**\"),\n    paxdep = md(\"**D√©parts**\"),\n    paxarr = md(\"**Arriv√©e**\"),\n    paxtra = md(\"**Transit**\")\n  ) %&gt;%\n  tab_header(\n    title = md(\"**Statistiques de fr√©quentation**\"),\n    subtitle = md(\"Classement des a√©roports\")\n  ) %&gt;%\n  tab_style(\n    style = cell_fill(color = \"powderblue\"),\n    locations = cells_title()\n  ) %&gt;%\n  tab_source_note(source_note = md(\"_Source: DGAC, √† partir des donn√©es sur data.gouv.fr_\"))\n  \ntable_aeroports\n\n\n\n\nR√©ponse question 6\ntable_aeroports &lt;- table_aeroports %&gt;%\n  opt_interactive()\ntable_aeroports\n\n\n\n\n\n\nStatistiques de fr√©quentation\nClassement des a√©roports\n\n\n\n\n\n\nSource: DGAC, √† partir des donn√©es sur data.gouv.fr\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution sugg√©r√©e pour l‚Äôexercice ci-dessus\n\ntable_gt = (\n  GT(stats_aeroports.head(15))\n  .cols_hide(columns = stats_aeroports.filter(like = \"apt\").columns.tolist())\n  .fmt_number(columns = stats_aeroports.filter(like = \"pax\").columns.tolist(), compact = True)\n  .fmt_markdown(columns = \"name_clean\")\n  .cols_label(\n    name_clean = md(\"**A√©roport**\"),\n    paxdep = md(\"**D√©parts**\"),\n    paxarr = md(\"**Arriv√©e**\"),\n    paxtr = md(\"**Transit**\")\n  ) \n  .tab_header(\n    title = md(\"**Statistiques de fr√©quentation**\"),\n    subtitle = md(\"Classement des a√©roports\")\n  )\n  .tab_source_note(\n    source_note = md(\"_Source: DGAC, √† partir des donn√©es sur data.gouv.fr_\")\n  )\n)\n\n\n\n\nNous proposons de transformer ce code en fonction, cela facilitera l‚Äôutilisation ult√©rieure de celui-ci dans notre application.\n\n\n\n\n\n\n Exercice 4c (optionnel): transformer en fonction notre cha√Æne gt\n\n\n\n\n\nCet exercice est optionnel. Transformer le code ci-dessus en fonction qui sera enregistr√©e dans R/tables.R () ou src/tables.py (). Mettre √† jour main.R ou main.py pour utiliser ceci dans votre application.\n\n\n\n\n\n\n\n\n\nCode de R/tables.R\n\n\n\nR/tables.R\n\ncreate_table_airports &lt;- function(stats_aeroports){\n\n  stats_aeroports_table &lt;- stats_aeroports %&gt;%\n    mutate(name_clean = paste0(str_to_sentence(apt_nom), \" _(\", apt, \")_\")\n    ) %&gt;%\n    select(name_clean, everything())\n    \n  table_aeroports &lt;- gt(stats_aeroports_table)\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    cols_hide(columns = starts_with(\"apt\"))\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    fmt_number(columns = starts_with(\"pax\"), suffixing = TRUE)\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    fmt_markdown(columns = \"name_clean\")\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    cols_label(\n      name_clean = md(\"**A√©roport**\"),\n      paxdep = md(\"**D√©parts**\"),\n      paxarr = md(\"**Arriv√©e**\"),\n      paxtra = md(\"**Transit**\")\n    ) %&gt;%\n    tab_header(\n      title = md(\"**Statistiques de fr√©quentation**\"),\n      subtitle = md(\"Classement des a√©roports\")\n    ) %&gt;%\n    tab_style(\n      style = cell_fill(color = \"powderblue\"),\n      locations = cells_title()\n    ) %&gt;%\n    tab_source_note(source_note = md(\"_Source: DGAC, √† partir des donn√©es sur data.gouv.fr_\"))\n  \n  table_aeroports &lt;- table_aeroports %&gt;%\n    opt_interactive()\n  \n  return(table_aeroports)\n\n}\n\n\n\n\nCode de main.R\n\n\n\nmain.R\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(gt)\nlibrary(leaflet)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/divers_functions.R\")\nsource(\"correction/R/tables.R\")\nsource(\"correction/R/figures.R\")\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\nyear &lt;- YEARS_LIST[1]\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\ntable_airports &lt;- create_table_airports(stats_aeroports)\n\n\n\n\n\n\nCode de src/tables.py\n\n\n\nstc/tables.py\n\n\n\n\n\n\nCode de main.py\n\n\n\nmain.R\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(gt)\nlibrary(leaflet)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/divers_functions.R\")\nsource(\"correction/R/tables.R\")\nsource(\"correction/R/figures.R\")\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\nyear &lt;- YEARS_LIST[1]\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\ntable_airports &lt;- create_table_airports(stats_aeroports)"
  },
  {
    "objectID": "index.html#valorisation-3-carte-des-a√©roports",
    "href": "index.html#valorisation-3-carte-des-a√©roports",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "4.5 Valorisation 3: Carte des a√©roports",
    "text": "4.5 Valorisation 3: Carte des a√©roports\nLa troisi√®me valorisation qui sera int√©gr√©e dans l‚Äôapplication web est une carte interactive du trafic de nos a√©roports. Cette carte va √™tre assez basique. Si vous d√©sirez mettre en oeuvre des visualisations plus complexes, vous pouvez tout √† fait le faire.\nPour cet exercice, nous allons fixer une date pour prototyper notre code. Cela nous facilitera la transformation ult√©rieure en fonction.\n\n\n\n\n\nmonths &lt;- 1\nyears &lt;- 2019\n\nVoici √©galement une palette de couleurs qui sera utile √† la fin de l‚Äôexercice.\n\npalette &lt;- c(\"green\", \"blue\", \"red\")\n\n\n\n\nmonths = 1\nyears = 2019\n\nVoici √©galement une palette de couleurs qui sera utile √† la fin de l‚Äôexercice.\n\npalette = c(\"green\", \"blue\", \"red\")\n\n\n\n\n\n\n\n\n\n\n Exercice 5: carte a√©rienne du trafic a√©roportuaire\n\n\n\n\n\n\nCr√©er un dataframe trafic_date en ne conservant que les observations de pax_apt_all √©gales √† un certain mois et ann√©e (vous pouvez vous inspirer d‚Äôun filtre fait pr√©c√©demment). Utiliser celui-ci en faisant une jointure avec airports_location par le biais des variables, respectivement, Code.OACI et apt. Nommer ce dataframe trafic_aeroports\nA partir de l‚Äôexemple de d√©marrage de leaflet  ou de l‚Äôexemple canonique folium (), cr√©er une carte interactive qui affiche, lorsqu‚Äôon clique sur l‚Äôun des marqueurs, le nom de l‚Äôa√©roport et sa fr√©quentation.\nCr√©er une variable nomm√©e volume qui classe chaque observation dans son tercile et transforme la valeur en couleur √† partir de palette.\n\nReproduire une carte similaire √† celle pr√©sent√©e plus bas:\n\nEn , vous aurez besoin de la fonction addAwesomeMarkers et de l‚Äôexemple de code ci-dessous\nEn , il vous suffit de modifier les param√®tres de l‚Äôargument icon\n\n\n# Aide pour l'exemple R\nicons &lt;- awesomeIcons(\n  icon = 'plane',\n  iconColor = 'black',\n  library = 'fa',\n  markerColor = trafic_aeroports$color\n)\n\n\n\n\n\n\nSubtilit√© par rapport √† l‚Äôexemple de la documentation pour \n\n\n\n\n\nPar rapport √† l‚Äôexemple dans la documentation, il faut l√©g√®rement modifier le code de sorte √† faire icon=icons[] et non icon = icons.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 1\ntrafic_date &lt;- pax_apt_all %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  ) %&gt;%\n  filter(mois %in% months, an %in% years)\ntrafic_aeroports &lt;- airports_location %&gt;%\n  inner_join(trafic_date, by = c(\"Code.OACI\" = \"apt\"))\n\n\n\n\nQuestion 2\nlibrary(leaflet)\n  \nleaflet(trafic_aeroports) %&gt;% addTiles() %&gt;%\n  addMarkers(popup = ~paste0(Nom, \": \", trafic)) \n\n\n\n\nQuestion 3\ntrafic_aeroports &lt;- trafic_aeroports %&gt;%\n  mutate(\n    volume = ntile(trafic, 3)\n) %&gt;%\n  mutate(\n    color = palette[volume]\n  )\n\n\n\n\nQuestion 4\nicons &lt;- awesomeIcons(\n  icon = 'plane',\n  iconColor = 'black',\n  library = 'fa',\n  markerColor = trafic_aeroports$color\n)\n\n\ncarte_interactive &lt;- leaflet(trafic_aeroports) %&gt;% addTiles() %&gt;%\n  addAwesomeMarkers(\n  icon=icons[],\n  label=~paste0(Nom, \"\", \" (\",Code.OACI, \") : \", trafic, \" voyageurs\")\n)\n\n\n\n\nVoir la solution de l‚Äôexercice suivant\n\n\n\n\n\n\n\n\n\nComme pr√©c√©demment, nous proposons de transformer la production de cette carte en fonction, cela nous permettra d‚Äôavoir une application l√©g√®re. L√† encore c‚Äôest un exercice optionnel mais int√©ressant √† faire pour d√©couvrir la logique de la programmation fonctionnelle.\n\n\n\n\n\n\n Exercice 5b (optionnel): une fonction pour notre carte\n\n\n\n\n\n\nCr√©er une fonction map_leaflet_airport avec les arguments df, airports_location, month et year produisant la carte. Ins√©rer celle-ci dans le script R/figures.R (dans src/figures.py pour Python).\nMettre √† jour main.R ou main.py pour utiliser cette fonction dans votre chaine. N‚Äôoubliez pas de d√©finir month et year dans votre script.\n\n\n\n\n\n\n\n\n\n\nCode de R/figures.R √† reprendre\n\n\n\nR/figures.R (fin du fichier)\n\n\nmap_leaflet_airport &lt;- function(df, airports_location, months, years){\n  \n  palette &lt;- c(\"green\", \"blue\", \"red\")\n\n  trafic_date &lt;- df %&gt;%\n    mutate(\n      date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n    ) %&gt;%\n    filter(mois %in% months, an %in% years)\n  trafic_aeroports &lt;- airports_location %&gt;%\n    inner_join(trafic_date, by = c(\"Code.OACI\" = \"apt\"))\n  \n  \n  trafic_aeroports &lt;- trafic_aeroports %&gt;%\n    mutate(\n      volume = ntile(trafic, 3)\n    ) %&gt;%\n    mutate(\n      color = palette[volume]\n    )  \n  \n  icons &lt;- awesomeIcons(\n    icon = 'plane',\n    iconColor = 'black',\n    library = 'fa',\n    markerColor = trafic_aeroports$color\n  )\n  \n  carte_interactive &lt;- leaflet(trafic_aeroports) %&gt;% addTiles() %&gt;%\n    addAwesomeMarkers(\n      icon=icons[],\n      label=~paste0(Nom, \"\", \" (\",Code.OACI, \") : \", trafic, \" voyageurs\")\n    )\n  \n  return(carte_interactive)\n}\n\n\n\n\nCode de main.R √† reprendre\n\n\n\nmain.R\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(gt)\nlibrary(leaflet)\n\nsource(\"correction/R/import_data.R\")\nsource(\"correction/R/create_data_list.R\")\nsource(\"correction/R/clean_dataframe.R\")\nsource(\"correction/R/divers_functions.R\")\nsource(\"correction/R/tables.R\")\nsource(\"correction/R/figures.R\")\n\nYEARS_LIST  &lt;- as.character(2018:2022)\nMONTHS_LIST &lt;- 1:12\nyear &lt;- YEARS_LIST[1]\nmonth &lt;- MONTHS_LIST[1]\n\n\n# Load data ----------------------------------\nurls &lt;- create_data_list(\"./sources.yml\")\n\n\npax_apt_all &lt;- import_airport_data(unlist(urls$airports))\npax_cie_all &lt;- import_compagnies_data(unlist(urls$compagnies))\npax_lsn_all &lt;- import_liaisons_data(unlist(urls$liaisons))\n\nairports_location &lt;- st_read(urls$geojson$airport)\n\nliste_aeroports &lt;- unique(pax_apt_all$apt)\ndefault_airport &lt;- liste_aeroports[1]\n\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\ntrafic_aeroports &lt;- pax_apt_all %&gt;%\n  mutate(trafic = apt_pax_dep + apt_pax_tr + apt_pax_arr) %&gt;%\n  filter(apt %in% default_airport) %&gt;%\n  mutate(\n    date = as.Date(paste(anmois, \"01\", sep=\"\"), format = \"%Y%m%d\")\n  )\n\nstats_aeroports &lt;- summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\nstats_liaisons  &lt;- summary_stat_liaisons(\n  create_data_from_input(pax_lsn_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly &lt;- plot_airport_line(trafic_aeroports,default_airport)\n\ntable_airports &lt;- create_table_airports(stats_aeroports)\n\ncarte_interactive &lt;- map_leaflet_airport(\n  pax_apt_all, airports_location,\n  month, year\n)\n\n\n\n\n\n\nCode de src/figures.py √† reprendre\n\n\n\nsrc/figures.py (fin du fichier)\n\n\n\n\n\n\nCode de main.py √† reprendre\n\n\n\nmain.py\n\nimport pandas as pd\nimport geopandas as gpd\nimport plotly.express as px\n\nimport src.import_data as sid\nfrom src.create_data_list import create_data_list\nfrom src.divers_functions import (\n  create_data_from_input,\n  summary_stat_airport\n)\nfrom src.tables import create_table_airports\nfrom src.figures import plot_airport_line, map_leaflet_airport\n\n\nYEARS_LIST = [str(year) for year in range(2018, 2023)]\nMONTHS_LIST = list(range(1, 13))\nyear = YEARS_LIST[0]\nmonth = MONTHS_LIST[0]\n\n# Load data ----------------------------------\nurls = create_data_list(\"./sources.yml\")\n\n\npax_apt_all = sid.import_airport_data(urls['airports'].values())\npax_cie_all = sid.import_airport_data(urls['compagnies'].values())\npax_lsn_all = sid.import_airport_data(urls['liaisons'].values())\n\nairports_location = gpd.read_file(\n    urls['geojson']['airport']\n)\n\n\nliste_aeroports = pax_apt_all['apt'].unique()\ndefault_airport = liste_aeroports[0]\n\n\n# OBJETS NECESSAIRES A L'APPLICATION ------------------------\n\npax_apt_all['trafic'] = pax_apt_all['apt_pax_dep'] + \\\n  pax_apt_all['apt_pax_tr'] + \\\n  pax_apt_all['apt_pax_arr']\n\ntrafic_aeroports = (\n  pax_apt_all\n  .loc[pax_apt_all['apt'] == default_airport]\n)\ntrafic_aeroports['date'] = pd.to_datetime(\n  trafic_aeroports['anmois'] + '01', format='%Y%m%d'\n)\n\nstats_aeroports = summary_stat_airport(\n  create_data_from_input(pax_apt_all, year, month)\n)\n\n\n# VALORISATIONS ----------------------------------------------\n\nfigure_plotly = plot_airport_line(trafic_aeroports, default_airport)\n\ntable_airports = create_table_airports(stats_aeroports)\n\ncarte_interactive = map_leaflet_airport(\n  pax_apt_all, airports_location,\n  month, year\n)"
  },
  {
    "objectID": "index.html#conteneurisation-de-lapplication",
    "href": "index.html#conteneurisation-de-lapplication",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "6.1 Conteneurisation de l‚Äôapplication",
    "text": "6.1 Conteneurisation de l‚Äôapplication\nPour d√©ployer son application, la premi√®re √©tape consiste √† la conteneuriser, ce qui signifie la mettre dans une sorte de bo√Æte virtuelle contenant tout ce dont l‚Äôapplication a besoin pour fonctionner. Le conteneur s√©pare l‚Äôapplication de son environnement ext√©rieur, ce qui permet d‚Äô√©viter les conflits avec d‚Äôautres applications ou d√©pendances sur le m√™me syst√®me. Puisque le conteneur contient tout ce dont l‚Äôapplication a besoin (comme les biblioth√®ques et les d√©pendances), l‚Äôapplication peut √™tre d√©plac√©e et ex√©cut√©e sur n‚Äôimporte quel syst√®me qui supporte les conteneurs, sans se soucier des diff√©rences entre ces syst√®mes.\nAinsi, conteneuriser une application permet de la rendre plus facile √† d√©ployer, plus fiable et plus portable (en utilisant efficacement les ressources du syst√®me). Docker est un outil populaire pour cr√©er et g√©rer des conteneurs. Le fichier Dockerfile contient le code n√©cessaire pour construire l‚Äôimage Docker de l‚Äôapplication finale situ√©e dans le r√©pertoire correction. Vous pouvez consulter la documentation Docker pour tenter de comprendre comment l‚Äôimage est construite.\nNous ne vous demandons pas de construire l‚Äôimage vous-m√™me, l‚Äôimage est d√©j√† publique sur Dockerhub et peut-√™tre utilis√©e pour d√©ployer l‚Äôapplication. N√©anmoins, il est int√©ressant, pour comprendre la logique de fonctionnement de Docker, de regarder la recette de construction de cette image\n\n\n\n\n\n\nDockerfile\n\nFROM inseefrlab/onyxia-rstudio:r4.3.2-2024.02.13\n\n# Add files necessary for the running app\nADD correction/global.R .\nADD correction/ui.R .\nADD correction/server.R .\nADD correction/sources.yml .\nCOPY correction/R R/\nADD renv.lock .\nADD renv .\n\n\n# Expose port where shiny app will broadcast\nARG SHINY_PORT=3838\nEXPOSE $SHINY_PORT\nRUN echo \"local({options(shiny.port = ${SHINY_PORT}, shiny.host = '0.0.0.0')})\" &gt;&gt; /usr/local/lib/R/etc/Rprofile.site\n\nRUN Rscript -e \"renv::restore()\"\n\n# Endpoint\nCMD [\"Rscript\", \"-e\", \"shiny::runApp()\"]\n\n\n\n\n\nDockerfile\n\nFROM inseefrlab/onyxia-jupyter-python:py3.10.9\n\n# Add files necessary for the running app\nADD correction/app.py .\nADD correction/sources.yml .\nADD requirements.txt .\nCOPY correction/src src/\nCOPY correction/.streamlit .streamlit/\n\n\nRUN pip install -r requirements.txt\n\nEXPOSE 8000\nCMD [\"streamlit\", \"run\", \"app.py\", \"--server.port=8000\", \"--server.address=0.0.0.0\"]\n\n\n\n\nLes principales √©tapes de cette construction d‚Äôimage sont les suivantes :\n\n1Ô∏è‚É£ On part d‚Äôune image de base qui correspond √† celle dans laquelle on a d√©velopp√© notre application et qui fonctionnait. On pourrait partir d‚Äôun environnement plus minimaliste (une machine Linux avec seulement R install√©, comme les images rocker) mais nous aurions peut-√™tre √† installer des librairies syst√®me en plus par un processus d‚Äôessai-erreur co√ªteux en temps.\n\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\nFROM inseefrlab/onyxia-rstudio:r4.3.2-2024.02.13\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\nFROM inseefrlab/onyxia-jupyter-python:py3.10.9\n\n\n\n\n\n\n2Ô∏è‚É£ On ajoute dans le conteneur les fichiers indispensables au fonctionnement de notre application. Le conteneur, par d√©faut, n‚Äôa pas les fichiers de notre projet, on doit donc dire √† Docker quels fichiers on d√©sire avoir dans notre application.\n\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\n# Add files necessary for the running app\nADD correction/global.R .\nADD correction/ui.R .\nADD correction/server.R .\nADD correction/sources.yml .\nCOPY correction/R R/\nADD renv.lock .\nADD renv .\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\n# Add files necessary for the running app\nADD correction/app.py .\nADD correction/sources.yml .\nADD requirements.txt .\nCOPY correction/src src/\nCOPY correction/.streamlit .streamlit/\n\n\n\n\n\n\n3Ô∏è‚É£ On d√©finit des param√®tres sur le routage de notre application dans le conteneur (seulement n√©cessaire pour la solution ). Ces param√®tres nous seront utiles ult√©rieurement, lors du d√©ploiement.\n\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\n# Expose port where shiny app will broadcast\nARG SHINY_PORT=3838\nEXPOSE $SHINY_PORT\nRUN echo \"local({options(shiny.port = ${SHINY_PORT}, shiny.host = '0.0.0.0')})\" &gt;&gt; /usr/local/lib/R/etc/Rprofile.site\n\n\n\n\nCette √©tape n‚Äôest pas n√©cessaire.\n\n\n\n\n4Ô∏è‚É£ On restaure l‚Äôenvironnement avec renv () ou pip (). De cette mani√®re, on est assur√© que l‚Äôapplication aura le m√™me environnement que celui que nous avons pr√©vu lors de la phase de d√©veloppement.\n\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\nRUN Rscript -e \"renv::restore()\"\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\nRUN pip install -r requirements.txt\n\n\n\n\n\n\n5Ô∏è‚É£ On d√©finit la commande qui sera ex√©cut√©e au lancement de notre application. En l‚Äôoccurrence, c‚Äôest une ligne de commande Linux pour lancer l‚Äôapplication Shiny ou Streamlit\n\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\n\n# Endpoint\n\n\n\n\n\n\nPartie du Dockerfile en question\n\n\n\nDockerfile\n\nEXPOSE 8000\nCMD [\"streamlit\", \"run\", \"app.py\", \"--server.port=8000\", \"--server.address=0.0.0.0\"]\n\n\n\n\n\nSi le Dockerfile est la recette pour cr√©er notre application, o√π se trouve la cuisine pour pr√©parer notre plat ? En g√©n√©ral, on passe par des syst√®mes d‚Äôint√©gration continue, des serveurs mis √† disposition en compl√©ment de forges Git pour tester le Dockerfile. Pour en savoir plus sur l‚Äôint√©gration continue, vous pouvez consulter le cours de 3e ann√©e de l‚ÄôENSAE.\nVoici le fichier .github/workflows/app.yaml qui contient la suite d‚Äôinstruction donn√©e aux serveurs de Github pour ex√©cuter notre chaine de production de l‚Äôimage Docker. Celui-ci est quasiment une reprise mot pour mot de l‚Äôexemple de la documentation Github.\n\n\nLe workflow Github en question ( et )\n\n\n\n.github/workflows/app.yaml\n\nname: Dockerize\n\non:\n  push:\n    tags:\n      - \"*\"\n    branches:\n      - main\n\njobs:\n  docker-shiny:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Docker meta\n        id: docker_meta\n        uses: docker/metadata-action@v5\n        with:\n          images: inseefrlab/funathon2024-sujet2\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v3\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n      - name: Login to DockerHub\n        if: github.event_name != 'pull_request'\n        uses: docker/login-action@v3\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v6\n        with:\n          context: .\n          file: ./docker/Dockerfile\n          push: ${{ github.event_name != 'pull_request' }}\n          tags: |\n            ${{ steps.docker_meta.outputs.tags }}\n            ${{ github.ref == 'refs/heads/main' && 'inseefrlab/funathon2024-sujet2:shiny-test2' || '' }}\n          labels: ${{ steps.docker_meta.outputs.labels }}\n      - name: Image digest\n        run: echo ${{ steps.docker_build.outputs.digest }}\n  docker-streamlit:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Docker meta\n        id: docker_meta\n        uses: docker/metadata-action@v5\n        with:\n          images: inseefrlab/funathon2024-sujet2\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v3\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n      - name: Login to DockerHub\n        if: github.event_name != 'pull_request'\n        uses: docker/login-action@v3\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v6\n        with:\n          context: .\n          file: ./docker/Dockerfile_python\n          push: ${{ github.event_name != 'pull_request' }}\n          tags: |\n            ${{ steps.docker_meta.outputs.tags }}\n            ${{ github.ref == 'refs/heads/main' && 'inseefrlab/funathon2024-sujet2:streamlit-test2' || '' }}\n          labels: ${{ steps.docker_meta.outputs.labels }}\n      - name: Image digest\n        run: echo ${{ steps.docker_build.outputs.digest }}"
  },
  {
    "objectID": "index.html#utilisation-de-limage-docker-pour-mettre-√†-disposition-le-shiny-ou-streamlit",
    "href": "index.html#utilisation-de-limage-docker-pour-mettre-√†-disposition-le-shiny-ou-streamlit",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "6.2 Utilisation de l‚Äôimage Docker pour mettre √† disposition le Shiny ou Streamlit",
    "text": "6.2 Utilisation de l‚Äôimage Docker pour mettre √† disposition le Shiny ou Streamlit\nNous avons cr√©√© une image Docker qui est disponible sur Dockerhub, le r√©seau social de Docker. Pour rendre celle-ci vivante, nous devons la d√©ployer dans un conteneur.\n\n\n\n\n\n\n Exercice 7 : D√©ploiement de l‚Äôapplication Shiny\n\n\n\n\n\nL‚Äôimage peut √† pr√©sent √™tre r√©cup√©r√©e et d√©ploy√©e. Dans notre cas, on va la d√©ployer sur un cluster Kubernetes, l‚Äôinfrastructure sous-jacente du SSP Cloud. Le fonctionnement de Kubernetes est technique et nous ne rentrerons pas dans les d√©tails ici. Les fichiers n√©cessaires au d√©ploiement se trouvent dans un d√©p√¥t s√©par√© (https://github.com/InseeFrLab/funathon2024_sujet2_cd), nomm√© d√©p√¥t Git-ops.\nAfin de d√©ployer l‚Äôapplication, suivre les instructions suivantes :\n\nInspecter les fichiers shiny/deployment.yml, shiny/service.yml et shiny/ingress.yml (parcours ) ou streamlit/deployment.yml, streamlit/service.yml et streamlit/ingress.yml (parcours ) et rep√©rer les √©l√©ments suivants :\n\nL‚Äôemplacement o√π est sp√©cifi√© l‚Äôimage √† d√©ployer;\nL‚Äôemplacement o√π sont sp√©cifi√©es les ressources computationnelles allou√©es;\nL‚Äôemplacement o√π est sp√©cifi√©e l‚ÄôURL √† laquelle sera expos√©e l‚Äôapplication sur Internet. La modifier (√† 2 reprises) pour y indiquer une adresse personalis√©e pour le d√©ploiement. Seule contrainte, elle doit √™tre de la forme *.lab.sspcloud.fr;\n\nOuvrir un Terminal;\nCl√¥ner le d√©p√¥t (git clone https://github.com/InseeFrLab/funathon2024_sujet2_cd)\nSe placer √† la racine du projet (cd funathon2024_sujet2_cd);\nAppliquer les contrats Kubernetes avec la commande kubectl apply -f shiny/ ou kubectl apply -f streamlit/ selon le langage utilis√© ;\nV√©rifier le lancement du conteneur avec la commande kubectl get pods. Le nom associ√© devrait √™tre de la forme funathon2024-sujet2-deployment-*;\nAttendre que le conteneur obtienne le statut Running.\nCopier le nom associ√© √† votre service et faire kubectl logs &lt;nom_copi√©&gt;\n\n\nEntrer dans un navigateur l‚ÄôURL sp√©cifi√©e dans le fichier streamlit/ingress.yaml ou shiny/ingress.yaml, et v√©rifier que l‚Äôapplication fonctionne correctement ! Jouer avec et observer, dans le terminal que vous aviez ouvert, l‚Äô√©volution de vos logs quand vous faites une action"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Un tableau de bord du trafic a√©rien avec  ou ",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nPour le cr√©er, vous pouvez taper F1 et dans la barre qui s‚Äôouvre, taper notebook et cliquer sur Create: New Jupyter Notebook. Enregistrer le fichier‚Ü©Ô∏é\nCes fichiers ne sont pas g√©n√©r√©s manuellement. Ce sont des outils adapt√©s (renv pour R, pip pour Python) qui font ce travail de versionnage de l‚Äôenvironnement.‚Ü©Ô∏é\nSi vous utilisez renv dans vos futurs projets, ce que nous vous recommandons, cette commande n‚Äôest pas √† inscrire dans vos scripts. Vous pouvez indiquer que cette commande est n√©cessaire dans le README de votre projet.‚Ü©Ô∏é\nSi vous √™tes peu familier avec ce type de fichiers, vous pouvez consulter la fiche utilitR sur le sujet ()‚Ü©Ô∏é\nSi vous √™tes peu familier avec les donn√©es g√©ographiques, vous pouvez retenir l‚Äôid√©e qu‚Äôil s‚Äôagit de donn√©es traditionnelles auxquelles s‚Äôajoute une dimension spatiale. Cette derni√®re vise √† localiser les donn√©es sur la terre. La localisation se fait dans un espace √† deux dimensions (espace cart√©sien) alors que notre plan√®te est une sph√®re en trois dimensions. Le principe d‚Äôun syst√®me de projection est de faire ce passage en deux dimensions des positions. Le plus connu est le syst√®me GPS, qui est un h√©ritier lointain de la repr√©sentation du monde par Mercator. Ce syst√®me est connu sous le nom de WGS 84 et porte le code EPSG 4326. L‚Äôautre syst√®me √† retenir est le Lambert 93 (code EPSG 2154) qui est la projection l√©gale en France (celle-ci, a contrario du Mercator, ne d√©forme pas la France sur une carte). Pour en savoir plus sur les syst√®mes de repr√©sentation, les avantages et inconv√©nients de chacun, il existe de nombreuses ressources en ligne. Des √©l√©ments introductifs, et des d√©monstrations interactives, en lien avec la librairie Geopandas de Python sont disponibles ici.‚Ü©Ô∏é\nVous perdrez la mise en forme du header du tableau qui n‚Äôest pas conciliable avec l‚Äôinteractivit√©.‚Ü©Ô∏é"
  }
]